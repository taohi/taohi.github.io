<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[You Are Not Late]]></title>
    <url>%2F2018%2F01%2F17%2Fyouarenotlate.html</url>
    <content type="text"><![CDATA[纽约时间比加州时间早三个小时，New York is 3 hours ahead of California,但加州时间并没有变慢。but it does not make California slow.有人22岁就毕业了，Someone graduated at the age of 22,但等了五年才找到稳定的工作！but waited 5 years before securing a good job!有人25岁就当上CEO，Someone became a CEO at 25,却在50岁去世。and died at 50.也有人迟到50岁才当上CEO，While another became a CEO at 50,然后活到90岁。and lived to 90 years.有人单身，Someone is still single,同时也有人已婚。while someone else got married.奥巴马55岁就退休，Obama retires at 55,川普70岁才开始当总统。but Trump starts at 70.世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone.身边有些人看似走在你前面，People around you might seem to go ahead of you,也有人看似走在你后面。some might seem to be behind you.但其实每个人在自己的时区有自己的步程。But everyone is running their own RACE, in their own TIME.不用嫉妒或嘲笑他们。Don’t envy them or mock them.他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours!生命就是等待正确的行动时机。Life is about waiting for the right moment to act.所以，放轻松。So, RELAX.你没有落后。You’re not LATE.你没有领先。You’re not EARLY.在命运为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE Destiny set up for you. 大学室友在qq上发来的一段最近很火的诗。很喜欢，复制到这里，给自己加个油。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我的2017年度总结]]></title>
    <url>%2F2018%2F01%2F01%2Fannual-review-2017.html</url>
    <content type="text"><![CDATA[请输入密码以访问这篇文章. 密码错啦! No content to display! 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]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阳仔带病打DOTA]]></title>
    <url>%2F2017%2F02%2F27%2Ftuoyouping.html</url>
    <content type="text"><![CDATA[阳仔拖油瓶记 广水阳仔，年方二八，丁酉年二月底患病，带病打dota。 然，战六局至午夜，连输五场。祸及队友。险跌分至一千内。 每思及此，阳仔不觉惭愧，而队友捶胸顿足，内心愤懑潸然泪下。 谨以此文，劝服阳仔，有病早治，无病早防。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禹玮二愣子]]></title>
    <url>%2F2015%2F12%2F21%2Fyuwei2.html</url>
    <content type="text"><![CDATA[禹玮二愣子哈哈哈哈哈！]]></content>
  </entry>
  <entry>
    <title><![CDATA[WIN10快捷键]]></title>
    <url>%2F2015%2F08%2F11%2Fwin10-shortcut.html</url>
    <content type="text"><![CDATA[创建新的虚拟桌面：Win + Ctrl + D关闭当前虚拟桌面：Win + Ctrl + F4切换虚拟桌面： Win + Ctrl +左/右 切换窗口：Alt + Tab任务视图：Win + Tab Win键 桌面与开始菜单切换按键Win + R 打开运行对话框Win + A 操作中心Win + I Win10设置栏Ctrl+Alt+Del 任务管理器Alt+F4 关机快捷键 Win + 数字键：打开或切换位于任务栏指定位置的程序Win+D：显示桌面Win+ P：演示设置Win+L：锁住电脑或切换用户Win+PrtSc 截屏Win+ G 打开游戏录制Win+ALT+R屏幕录制]]></content>
      <tags>
        <tag>win10</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业事项记录]]></title>
    <url>%2F2015%2F04%2F17%2Fgraduation-note.html</url>
    <content type="text"><![CDATA[毕业论文及答辩 论文被抽查到盲审(50%概率)，送校外和校内各一位专家审查。审查结果分ABCD。A可直接参加校内答辩。 在学校内部hub系统上申请答辩。录入论文相关信息。 制作答辩PPT。 参加答辩。 填写档案袋以及(共6种资料)签字盖章。 根据答辩，重新修改完善论文，最终定稿。和档案袋一起上交。 在研究生院学位信息录入系统录入学位信息。 三方办理流程 找工作，与公司签两方工作意向协议。这个用于让自己放心。 拿到学校发的三方协议，自己签字，然后给公司盖章。 公司寄回三方协议，在学校就业网站填好毕业去向登记。三方找学院盖章。 将三方找学校就业办盖章。给一份就业办，给一份学院，自己留一份，给一份公司。 三方毁约流程因为和腾讯毁约。经历了三方毁约。发生在第一次给公司寄出三方之后。 找新单位开具工作接收函。 打电话找腾讯HR协商毁约，赔偿5K违约金，腾讯寄回三方和毁约声明。 拿三方、毁约声明、新单位接收函和个人毁约申请，去找学院盖章。 拿上述一堆材料，去研究生就业办，登记并领取新三方。 重新走正常三方办理流程。 户口、档案和派遣(待写) 带三方去和人才市场签订代理协议。 毕业了把档案和户口托管到人才市场。托管户口需要劳动合同和社保证明 党组织关系转移到公司。 其他事项 填写研究生就业推荐表 填写毕业研究生登记表]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux虚拟文件系统]]></title>
    <url>%2F2015%2F02%2F12%2Flinux-vfs.html</url>
    <content type="text"><![CDATA[本文Linux虚拟文件系统的几个重要对象。它们在Linux编程中比较重要。在进程编程等场景经常用到。 file对象file对象是在进程观点上，进程中打开的文件的表示。 dentry对象它表示一个实际的文件。不同进程打开同一个文件时，它们有不同的file对象，但是最终指向同一个dentry对象。 inode对象linux将文件与文件的属性分开表示。inode对象包含了一个文件相关的所有属性信息。比如文件大小，文件权限，操作方法集，对应的块设备，修改时间等。 super_block对象超级块对象。它包含磁盘上文件的一些元数据。是对文件系统具体的描述。 如下两张图，能够将这些对象的关系看得很清楚。 文件描述符从上图知道，在进程中打开的文件，对应的文件描述符，就是file_struct结构体中，file指针数组fd_array的下标。所以，进程打开文件时，分配的文件描述符按照从小到大的值依次分配。有了文件描述符，内核就能够去索引对应的file结构体，从fops去获得对文件的操作函数集，以便对文件进行各种操作。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>内核</tag>
        <tag>文件系统</tag>
        <tag>VFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分配malloc与sbrk]]></title>
    <url>%2F2015%2F02%2F12%2Fmalloc-sbrk.html</url>
    <content type="text"><![CDATA[malloc是C库函数。用于分配堆内存。是在运行时分配存储空间的函数。头文件: stdlib.h函数原型：void *malloc(unsigned int num_bytes); C库函数malloc1.组织结构空闲存储空间以空闲链表的方式组织，每个块包含一个长度，一个指向下一块的指针，以及一个指向自身存储空间的指针。按照存储地址升序组织。最后一块指向第一块。 2.分配过程有申请时，malloc顺序扫描空闲链表。直到找到一个足够大的块。算法为“首次适应”。寻找过程中，如果块大小等于需求大小，直接返回；如果块大小太大，分成两部分，一块为需求大小，将它返回(一般是块的后半部分)，另一块留在链表中；如果找不到足够大的块。调用sbrk向操作系统申请更大块加入空闲链表。 3.释放过程free首先搜索空闲块链表，找到相邻空闲块，则合并为一块。避免碎片。 Unix系统调用sbrk函数原型：char *sbrk(int incr); 它返回下一个内存空间。则sbrk(0)能得知堆的结束地址program break.sbrk是一个Linux的系统调用。它增加或者减少堆空间的长度。完成虚拟地址到物理地址的映射。在malloc申请空间不足时，malloc会调用sbrk来申请更多的内存加入到空闲块链表上。如下图，sbrk就是移动堆的program break的位置。 malloc/free与new/delete malloc是C标准库函数，new是C++的运算符。 对于用户自定义的对象而言，用malloc/free不能够执行构造函数和析构函数。因为malloc是库函数，不受编译器控制。 对于内置的数据对象，比如int char等，用new 和用malloc都可以。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存</tag>
        <tag>malloc</tag>
        <tag>sbrk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核定时器]]></title>
    <url>%2F2015%2F02%2F12%2Flinux-kernel-timer.html</url>
    <content type="text"><![CDATA[前提概念HZ：节拍率.linux一秒钟中断的次数，一般是100jiffies：系统从启动到当前的节拍数。如果系统启动n秒了，则 jiffies = n*HZ 头文件：linux/timer.h 12345678struct timer_list&#123; struct list_head entry; unsigned long expires; struct tvec_base *base; void (*function) (unsigned long); unsigned long data; .......&#125; 使用步骤 申请timer_list结构体 struct timer_list mytimer 初始化定时器init_timer(&amp;mytimer) 设置超时间隔，超时函数及其参数。 编写超时后处理函数 添加定时器add_timer(&amp;mytimer) 最终删除定时器del_timer_sync(&amp;mytimer)，该函数多处理器安全。 代码示例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/jiffies.h&gt;MODULE_LICENSE("Dual BSD/GPL");struct timer_list mytimer;int counter = 0;static void mytimer_handler(unsigned long data)&#123; printk("counter now:%d.\n",counter); counter ++; if (counter &gt;20) counter = 0; mod_timer(&amp;mytimer,jiffies + HZ);&#125;static int __init mytimer_init(void)&#123; printk("In function:%s\n",__func__); init_timer(&amp;mytimer); mytimer.expires = jiffies + HZ; mytimer.data = jiffies; mytimer.function = mytimer_handler; add_timer(&amp;mytimer); return 0;&#125;static void __exit mytimer_exit(void)&#123; printk("In function:%s\n",__func__); del_timer(&amp;mytimer);&#125;module_init(mytimer_init);module_exit(mytimer_exit); 程序中，每经过1秒定时器超时，count值加1并打印出来，然后mod_timer()修改定时器mytimer的expires值为再过1秒超时，再次激活定时器。 运行结果每隔一秒输出count值，count循环从0增加到20，直到手动卸载模块时，定时器被删除。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内核</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的多线程]]></title>
    <url>%2F2015%2F02%2F11%2Flinux-multi-thread.html</url>
    <content type="text"><![CDATA[一.Linux线程与进程的对比用户空间角度： 新进程创建时，申请独立的地址空间，包括堆、栈、代码段、数据段、BSS段等。并初始化为父进程的值。此后父子进程不能直接互相访问这些资源。 新线程创建时，只申请独立线程栈，与同进程的其它线程共享进程地址空间，包括的代码段、数据段、BSS段、堆、打开的库、mmap映射的文件、共享内存空间。 内核空间角度： Linux并不区分进程和线程。创建线程和进程时，都会创建新的PCB。 不同的是，新进程PCB的mm_struct会创建新地址空间；新线程PCB的mm_struct指向主进程的地址空间，与它共享。 总的说来进程是OS管理资源的基本单元；线程是Linux系统调度的基本单元。 二.线程基本操作头文件：pthread.h由于是POSIX线程库，gcc编译时要加上-pthread选项。 int pthread_create(p_tid,attr,func,arg);创建线程。新线程从func处开始执行，arg为传递给func的参数。 pthread_t pthead_self();获取线程自身tid。 pthread_exit(void *ptr);线程由自身退出，返回信息放在ptr里。 int pthread_join(tid, void **ptr);等待线程tid退出。ptr存放tid退出时返回信息。 int pthread_detach(tid);使线程tid进入分离状态。即线程自身独立出来。 int pthread_cancel(tid);取消同进程中的tid线程。它提出这个请求后立即返回。tid在可取消点的时候退出。 void pthread_cleanup_push(func,arg);void pthread_cleanup_pop(int execute);设置线程退出时需要调用的函数。 一个代码示例：123456789101112131415161718192021#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void *thread_func(void *arg)&#123; printf("msg from main:%s\n",(char *)arg); printf("thread id:%u\n",(unsigned)pthread_self()); pthread_exit("I am thread,exited");&#125;int main(int argc,char *argv[])&#123; pthread_t tid; void *thread_ret; pthread_create(&amp;tid,NULL,thread_func,"I am main"); pthread_join(tid,&amp;thread_ret); printf("msg from thread:%s\n",(char *)thread_ret); return 0;&#125; 运行结果：1234tao@taohi-xubuntu:~/linux_c$ ./pthread_exitmsg from main:I am mainthread id:3075636032msg from thread:I am thread,exited 三.线程私有数据一个全局变量，如果A线程修改了它，那么这个修改会在B线程可见。为了使得线程有私有全局变量，有如下接口：pthread_key_create(key,func);pthread_key_delete(key);pthread_setspecific(key,ptr);pthread_getspecific(key); 示例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;pthread_key_t key;void *tid1_func(void *arg)&#123; int i=10; printf("set key:%d in tid1\n",i); pthread_setspecific(key,&amp;i); sleep(2); printf("in tid1,after tid2 ends,key:%d\n",*(int *)pthread_getspecific(key));&#125;void *tid2_func(void *arg)&#123; int j=20; printf("set key:%d in tid2\n",j); pthread_setspecific(key,&amp;j); printf("in tid2,key:%d\n",*(int *)pthread_getspecific(key));&#125;void destruct(void *t)&#123; printf("key addr:%p\n",t);&#125;int main(int argc,char *argv[])&#123; pthread_t tid1,tid2; pthread_key_create(&amp;key,destruct); pthread_create(&amp;tid1,NULL,tid1_func,NULL); pthread_create(&amp;tid2,NULL,tid2_func,NULL); pthread_join(tid1,NULL); pthread_join(tid2,NULL); pthread_key_delete(key); return 0;&#125; 运行结果：1234567tao@taohi-xubuntu:~/linux_c$ ./pthread_keyset key:10 in tid1set key:20 in tid2in tid2,key:20key addr:0xb6d8934cin tid1,after tid2 ends,key:10key addr:0xb758a34c 四.线程同步方法线程并发访问共享资源，带来不确定性。所以需要同步机制。 4.1互斥锁mutex互斥锁是二元变量。线程只有获得锁，才能操作临界资源。操作完释放锁。造成死锁原因： 线程对同一个互斥锁加锁两次； A拥有甲锁，等乙锁，同时B拥有乙锁，等甲锁。 使用接口：pthread_mutex my_mutex;pthread_mutex_init(&amp;my_mutex,NULL);pthread_mutex_lock(&amp;my_mutex); 试着加锁，锁不上就阻塞等待加锁。pthread_mutex_trylock(&amp;my_mutex); 试着加锁，锁不上就返回pthread_mutex_unlock(&amp;my_mutex);pthread_mutex_destroy(&amp;my_mutex); 4.2读写锁读写锁比互斥锁并发度更高:如果A线程获得写锁：其他线程不能获得任何锁；如果A线程获得读锁：其他线程可以获得读锁，不能获得写锁。 使用接口：pthread_rwlock_t rwlock;pthread_rwlock_init(&amp;rwlock,NULL);pthread_rwlock_destroy(&amp;rwlock);pthread_rwlock_rdlock(&amp;rwlock);pthread_rwlock_wrlock(&amp;rwlock);pthread_rwlock_unlock(&amp;rwlock); 4.3条件变量默默忽略 五.线程和信号 每个线程有单独的信号屏蔽集合。 对同一个信号，所有线程共享相同的信号处理程序。比如线程1注册了SIGUSR1的处理函数，那么线程2收到SIGUSR1也会去调用这个处理函数。 如果一个线程收到终止信号，其他所有线程都将终止。 线程操作接口：pthread_kill(tid,signo);向线程tid发送signo信号。 pthread_procmask(how,mask,oldmask);设置线程信号屏蔽集合。 sigwait()等待一个或者多个信号发生。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void sig_handler(int signo)&#123; printf("tid=%u,sig=%d\n",(unsigned int)pthread_self(),signo);&#125;void *tid1_func(void *arg)&#123; int i; sigset_t set; signal(SIGUSR1,sig_handler); sigfillset(&amp;set); sigdelset(&amp;set,SIGUSR2); pthread_sigmask(SIG_SETMASK,&amp;set,NULL); for(i=0;i&lt;5;i++) &#123; printf("tid1=%u, set mask.\n",(unsigned int)pthread_self()); pause(); &#125;&#125;void *tid2_func(void *arg)&#123; int i; signal(SIGUSR2,sig_handler); for(i=0;i&lt;5;i++) &#123; printf("tid2=%u, not set mask.\n",(unsigned int)pthread_self()); pause(); &#125;&#125;int main(int argc ,char *argv[])&#123; pthread_t tid1,tid2; pthread_create(&amp;tid1,NULL,tid1_func,NULL); pthread_create(&amp;tid2,NULL,tid2_func,NULL); sleep(1); pthread_kill(tid1,SIGUSR1); sleep(1); pthread_kill(tid1,SIGUSR1); pthread_kill(tid1,SIGUSR2); pthread_kill(tid2,SIGUSR1); pthread_kill(tid2,SIGUSR2); sleep(1); pthread_kill(tid1,SIGKILL); pthread_join(tid1,NULL); pthread_join(tid2,NULL); return 0;&#125; 运行结果：123456789tao@taohi-xubuntu:~/linux_c$ ./pthread_signal tid1=3076352832, set mask. tid2=3067960128, not set mask. tid=3076352832,sig=12 tid=3067960128,sig=12 tid=3067960128,sig=10 tid2=3067960128, not set mask.tid1=3076352832, set mask.已杀死 六.线程属性控制int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);获取线程栈大小。通过stacksize指针返回。 int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);设置线程栈大小。 示例代码：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *tid_func(void *arg)&#123; pthread_attr_t attr; size_t stack_size=0; pthread_attr_getstacksize(&amp;attr,&amp;stack_size); printf("default pthread stack size:%d KB\n",stack_size/1024); stack_size=4*1024*1024; pthread_attr_setstacksize(&amp;attr,stack_size); pthread_attr_getstacksize(&amp;attr,&amp;stack_size); printf("after modify,stack size:%d KB\n",stack_size/1024); pthread_exit(NULL);&#125;int main(int argc ,char *argv[])&#123; pthread_t tid; pthread_create(&amp;tid,NULL,tid_func,NULL); pthread_join(tid,NULL); return 0;&#125; 输出结果:123tao@taohi-xubuntu:~/linux_c$ ./pthread_stackdefault pthread stack size:8192 KBafter modify,stack size:4096 KB 可以看到linux下线程默认栈大小为8M]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>多线程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信之六：共享内存]]></title>
    <url>%2F2015%2F02%2F11%2Fipc-share-memory.html</url>
    <content type="text"><![CDATA[共享内存允许两个进程共享一个给定的存储区。所以数据不需要在两个进程间复制。这是最快的一种IPC。头文件:sys/shm.h 一.共享内存示意图↓ 二.地址映射示意图↓(APUE) 三.共享内存的数据结构shmid_ds1234567891011struct shmid_ds &#123;struct ipc_perm shm_perm; /* see Section 15.6.2 */size_t shm_segsz; /* size of segment in bytes */pid_t shm_lpid; /* pid of last shmop() */pid_t shm_cpid; /* pid of creator */shmatt_t shm_nattch; /* number of current attaches */time_t shm_atime; /* last-attach time */time_t shm_dtime; /* last-detach time */time_t shm_ctime; /* last-change time */.....&#125;; 四.共享内存操作接口 创建:shmget() 控制:shmctl() 挂载映射:shmat() 分离:shmdt() 删除:shmctl(shm_id,IPC_RMID,0) 五.注意事项 进程操作共享内存区，要注意同步问题，可用信号量来同步。 根据进程知识，fork一个子进程，它继承父进程挂载的共享内存。 如果用exec执行新程序，则挂载的共享内存将被卸载。 如果进程调用exit()，则挂载的共享内存与进程脱离关系。 六.示例代码利用信号量来给共享内存区同步。发送端：如果信号量为0，往共享区写数据，将信号量加1；接收端：如果信号量为1，读出共享区数据，将信号量减1。如果接收到“end”，则删除共享内存，信号量。通信结束。 发送端代码：(为了简洁没有做错误处理)123456789101112131415161718192021222324252627282930313233343536373839404142//shm_sem_sender.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;string.h&gt;int main(int argc,char *argv[])&#123; int running = 1; int shmid; int semid; int value; void *share_memp=NULL; struct sembuf sem; sem.sem_num=0; sem.sem_flg=SEM_UNDO; semid=semget((key_t)123456,1,0666|IPC_CREAT); //设置信号初始值为0 semctl(semid,0,SETVAL,0); shmid=shmget((key_t)654321,(size_t)2048,0600|IPC_CREAT); share_memp = shmat(shmid,NULL,0); while(running) &#123; value=semctl(semid,0,GETVAL); if(value==0) &#123; printf("write data operate\n"); printf("please input:"); scanf("%s",(char *)share_memp); sem.sem_op=1; semop(semid,&amp;sem,1); &#125; if(strcmp(share_memp,"end")==0) running--; &#125; shmdt(share_memp); return 0;&#125; 接收端代码：(为了简洁没有做错误处理)12345678910111213141516171819202122232425262728293031323334353637383940414243//shm_sem_recv.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;string.h&gt;int main(int argc,char *argv[])&#123; int running = 1; int shmid; int semid; int value; void *share_memp=NULL; struct sembuf sem; sem.sem_num=0; sem.sem_flg=SEM_UNDO; semid=semget((key_t)123456,1,0666|IPC_CREAT); //设置信号初始值为0 semctl(semid,0,SETVAL,0); shmid=shmget((key_t)654321,(size_t)2048,0600|IPC_CREAT); share_memp = shmat(shmid,NULL,0); while(running) &#123; value=semctl(semid,0,GETVAL); if(value==1) &#123; printf("read data operate\n"); sem.sem_op=-1; semop(semid,&amp;sem,1); printf("%s",(char *)share_memp); &#125; if(strcmp(share_memp,"end")==0) running--; &#125; shmdt(share_memp); shmctl(shmid,IPC_RMID,0); semctl(semid,IPC_RMID,0); return 0;&#125;]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信四、五：信号量和消息队列]]></title>
    <url>%2F2015%2F02%2F11%2Fipc-msg-semaphore.html</url>
    <content type="text"><![CDATA[System V提供的IPC机制有三种：信号量、消息队列、共享内存。本文介绍前两种。头文件:sys/msg.h 和 sys/ipc.h使用ipcs可以查看系统正使用的IPC工具： IPC的ID与key键每一个IPC都用唯一的ID来标识、使用。一般利用key键来获得一个IPC的ID。而key可以通过ftok()产生。key_t ftok(char *pathname,int id); IPC权限结构ipc_perm12345678struct ipc_perm&#123; uid_t uid; gid_t gid; uid_t cuid; gid_t cgid; mode_t mode; ......&#125;; 进程通信之五：消息队列通信12345678910111213struct msqid_ds &#123;struct ipc_perm msg_perm; msgqnum_t msg_qnum; /* # of messages on queue */msglen_t msg_qbytes; /* max # of bytes on queue */pid_t msg_lspid; /* pid of last msgsnd() */pid_t msg_lrpid; /* pid of last msgrcv() */time_t msg_stime; /* last-msgsnd() time */time_t msg_rtime; /* last-msgrcv() time */time_t msg_ctime; /* last-change time */...&#125;; 代码示例：发送端和接收端利用消息队列进行通信。通信示意图：发送端代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//msg_sender#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define KEY_PATH "/home/tao"struct msgbuf&#123; int type; char ptr[0];&#125;;int main(int argc,char *argv[])&#123; key_t key; key=ftok(KEY_PATH,100); int msgid; msgid=msgget(key,IPC_CREAT|0600); printf("msgid=%d\n",msgid); pid_t pid; pid=fork(); if(pid==0) &#123; while(1) &#123; printf("input msg to be sent:"); char buf[128]; fgets(buf,128,stdin); struct msgbuf *ptr = malloc(sizeof(struct msgbuf)+strlen(buf)+1); ptr-&gt;type=1;//发送消息类型为1的消息 memcpy(ptr-&gt;ptr,buf,strlen(buf)+1); msgsnd(msgid,ptr,strlen(buf)+1,0); free(ptr); &#125; &#125; else &#123; struct msgbuf&#123; int type; char ptr[1024]; &#125;; while(1) &#123; struct msgbuf mybuf; memset(&amp;mybuf,'\0',1024); msgrcv(msgid,&amp;mybuf,1024,2,0);//接受消息类型为2的消息 printf("receive msg:%s\n",mybuf.ptr); &#125; &#125;&#125; 接收端代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//msg_receiver#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define KEY_PATH "/home/tao"struct msgbuf&#123; int type; char ptr[0];&#125;;int main(int argc,char *argv[])&#123; key_t key; key=ftok(KEY_PATH,100); int msgid; msgid=msgget(key,IPC_CREAT|0600); printf("msgid=%d\n",msgid); pid_t pid; pid=fork(); if(pid==0)//子进程发送消息 &#123; while(1) &#123; printf("input msg to be sent:"); char buf[128]; fgets(buf,128,stdin); struct msgbuf *ptr = malloc(sizeof(struct msgbuf)+strlen(buf)+1); ptr-&gt;type=2; //发送消息类型为2的消息 memcpy(ptr-&gt;ptr,buf,strlen(buf)+1); msgsnd(msgid,ptr,strlen(buf)+1,0); free(ptr); &#125; &#125; else &#123; struct msgbuf&#123; int type; char ptr[1024]; &#125;; while(1) &#123; struct msgbuf mybuf; memset(&amp;mybuf,'\0',1024); int ret=msgrcv(msgid,&amp;mybuf,1024,1,0);//接受消息类型为1的消息 printf("receive msg:%s\n",mybuf.ptr); &#125; &#125; return 0;&#125; 进程通信之四：信号量通信一般用于避免并发访问共享资源。比如生产者消费者问题。用的比较少。没啥好说的。需要时补充。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
        <tag>消息队列</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信之三：信号]]></title>
    <url>%2F2015%2F02%2F03%2Fipc-signal.html</url>
    <content type="text"><![CDATA[信号是进程间唯一异步通信机制，是一种软中断。头文件：signal.hLinux一共定义了32个非实时信号。编号0-31。常见的如下：1234567891011121314151617181920212223#define SIGNAL 0#define SIGHUP 1#define SIGINT 2#define SIGQUIT 3#define SIGTRAP 5#define SIGABRT 6#define SIGBUS 7#define SIGFPE 8 //算术异常#define SIGKILL 9 //杀死信号，不能被屏蔽#define SIGUSR1 10 //用户信号1#define SIGSEGV 11 //段错误#define SIGUSR2 12 //用户信号2#define SIGPIPE 13 //写没有读进程的管道#define SIGALRM 14 //闹钟超时#define SIGTERM 15#define SIGCHLD 17 //子进程改变作业状态#define SIGCONT 18#define SIGSTOP 19 //停止作业。它不能被用户屏蔽#define SIGTSTP 20...... 信号0特别说明：“signal 0″ is kind of like a moral equivalent of “ping”.signal 0 is just used to check process is exists or not.Using “kill -0 NNN” in a shell script is a good way to tell if PID “NNN” is alive or not. 一、信号基本工作原理 task_struct含有与信号相关的signal_struct, sighand_struct, sigpending等关键结构体。 发送给进程的信号，如果是私有信号(只发给进程的信号)，则放到sigpending指向的链表； 发送给进程的信号，如果是共享信号 (进程的所有线程共享)，则放到signal指向的链表； 如果安装了信号(即注册了信号处理函数)，则信号处理函数放入相应的sighand指向的数组，数组有64项，下标对应的是信号编号。 当进程每次从内核态返回用户态，就会调用do_signal检查链表是否有信号要处理，如果有，则根据信号编号为下标，去sighand数组索引找到相应的信号处理函数，删除链表的该信号，并到用户空间执行该函数。否则执行默认处理。 二、信号集结构体sigset_t123typedef struct&#123; unsigned long sig[2];&#125;sigset_t; 所以sigset_t一共含有64bit。为Linux可声明的最大信号数。 其中，sig[0]的32bit从1-31bit就对应常用的编号为1-31的信号。0表示信号存在，1表示没有该信号。 不要直接操作这些bit位。定义变量sigset_t myset，有专用接口如下： sigemptyset(&amp;myset);清空myset，也就是使得数组元素的bit都为0； sigfillset(&amp;myset);填满信号集myset,也就是使数组元素bit都为1； sigaddset(&amp;myset,SIGUSR1)把myset数组里与信号SIGUSR1编号对应的bit位置为1，相当于添加了SIGUSR1到这个信号集。 sigdelset(&amp;myset,SIGUSR2)从信号集myset删除SIGUSR2信号。 sigismember(&amp;myset,signo) 返回1 表示signo在信号集，0表示不在. 三、发送信号int kill(pid_t pid, int signo);给指定进程发信号 raise(int signo);给进程自己发信号 unsigned int alarm(unsigned int seconds);发送定时信号。 四、安装信号用signal安装信号signal(signo,handler);表示对编号为signo的信号，处理函数为handler。例子：1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void sig_handler(int signo)&#123; printf(&quot;signo=%d\n&quot;,signo);&#125;int main()&#123; if(signal(SIGUSR1,sig_handler)==SIG_ERR) &#123; printf(&quot;can&apos;t catch SIGUSR1\n&quot;); &#125; pause(); return 0;&#125; 其中handler可以不自定义，取SIG_ERR、SIG_DFL(用默认处理方法) 、SIG_IGN(忽略该信号)。 用sigaction安装信号int sigaction(int signo,struct sigaction *act,struct sigaction *oldact);结构体sigaction包括信号处理函数，屏蔽信号集，信号标志等。如下：123456struct sigaction&#123; void *sa_sigaction(int,struct siginfo *,void *); sigset_t sa_mask; unsigned long sa_flags; ....&#125; signo表示要安装的信号，act表示即将安装使用的信号处理信息(处理函数等)，oldact存储之前安装的信号处理信息。示例代码：1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void sig_handler(int signo,siginfo_t *info,void *p)&#123; printf("signo=%d\n",signo); printf("siginfo-&gt;signo:%d\n",info-&gt;si_signo); printf("sender pid=%d\n",info-&gt;si_pid);&#125;int main()&#123; struct sigaction act,oldact; sigemptyset(&amp;act.sa_mask); act.sa_flags=SA_SIGINFO; act.sa_sigaction=sig_handler; sigaction(SIGUSR1,&amp;act,&amp;oldact); pause(); return 0;&#125; 运行结果(在另一个终端手动向该进程发送SIGUSR1信号)：1234tao@taohi-xubuntu:~/linux_c$ ./sigaction_sa_sigactionsigno=10siginfo-&gt;signo:10sender pid=15656 sig_handler第二个参数为siginfo_t *info。它用于返回一个结构体指针info给sig_handler，包含了许多与该信号产生原因相关的信息，供信号处理函数sig_handler使用。大致内容如下：1234567891011typedef struct siginfo&#123; int si_signo; //信号编号 int si_errno; //错误信息 int si_code; //信号产生原因代码 pid_t si_pid; //发送者的进程ID uid_t si_uid; //发送者实际用户ID void *si_addr; // int si_status; // long si_band; // ......&#125;siginfo_t; 五、信号的屏蔽信号屏蔽：如果某信号被屏蔽，即使信号传递到进程，进程并不响应处理，而是让它处于屏蔽状态。只有当解除屏蔽后，进程才捕获并响应该信号。SIGKILL和SIGSTOP信号不能被屏蔽。 信号忽略：进程捕获并处理该信号，但是处理方式就是直接忽略，什么也不做。int sigprogmask(int how,sigset_t *set,sigset_t *oldset);说明：set 和oldset都是信号集合。函数中how的取值： SIG_BLOCK：将set信号集，添加到当前进程屏蔽信号集； SIG_UNBLOCK:将set信号集合，从当前进程屏蔽信号集删除； SIG_SETMASK:设置set为当前进程屏蔽信号集。 示例代码：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;void sighandler(int signo)&#123; printf("caught signo:%d\n",signo);&#125;int main()&#123; sigset_t newmask,oldmask,pendmask; //安装SIGUSR1的处理函数 signal(SIGUSR1,sighandler); sigemptyset(&amp;newmask); sigaddset(&amp;newmask,SIGUSR1); //屏蔽SIGUSR1 sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask); printf("SIGUSR1 blocked for 20s.\n"); sleep(20); //进程可以收到SIGUSR1，但是被屏蔽了，处于pending状态， //sigpending可以查看处于pending的所有信号。 sigpending(&amp;pendmask); if(sigismember(&amp;pendmask,SIGUSR1)) printf("SIGUSR1 is pending...\n"); //取消屏蔽SIGUSR1 printf("SIGUSR1 unblocked.\n"); sigprocmask(SIG_SETMASK,&amp;oldmask,NULL); return 0;&#125; 运行结果(在另一个终端不断发送SIGUSR1)：12345tao@taohi-xubuntu:~/linux_c$ ./sigprocmaskSIGUSR1 blocked for 20s.SIGUSR1 is pending...SIGUSR1 unblocked.caught signo:10 六、等待信号 pause()挂起当前进程，等待除了当前被屏蔽信号外的任意信号。此时才会唤醒进程。 int sigsuspend(sigset_t *set)将进程屏蔽信号集指定为set，等待除了set外的任意信号到达；到达后，处理到达的信号。然后sigsuspend返回，恢复之前的进程屏蔽信号集。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信之二：有名管道FIFO]]></title>
    <url>%2F2015%2F02%2F03%2Fipc-fifo.html</url>
    <content type="text"><![CDATA[有名管道FIFO是一个特殊文件。但并不是将信息真正存到磁盘，而是存到内存中。两个完全没有关联的进程，通过访问这个管道文件，实现进程间通信。 头文件#include &lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); 使用方式 创建一个FIFO文件：mkfifo(“/tmp/fifo”,0766)。 A进程以写方式打开FIFO文件：open(FIFO文件,O_WRONLY),调用write往里写数据。 B进程以读方式打开FIFO文件：open(FIFO文件,O_RDONLY),调用read读出数据。 阻塞现象 A进程以写(读)方式打开FIFO，将会阻塞在open()，直到B以读(写)方式打开FIFO。 默认方式下，若管道没有数据，读操作阻塞，直到有数据被写入。 默认方式下，若管道数据满了，写操作阻塞，直到有数据被读出。 实例代码程序fifo_write向管道写入数据1234567891011121314151617181920212223#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#define FIFO "/tmp/fifo"int main(int argc,char *argv[])&#123; int pipe_fd; int res; char buffer[]="helloworld!"; res=mkfifo(FIFO,0766); printf("PID %d opening FIFO O_WRONLY.\n",getpid()); pipe_fd=open(FIFO,O_WRONLY); printf("pipe_fd=%d.\n",pipe_fd); if(pipe_fd!=-1) res=write(pipe_fd,buffer,sizeof(buffer)); printf("PID %d finished.\n",getpid()); return 0;&#125; 程序fifo_read从管道读出数据：1234567891011121314151617181920212223242526#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#define FIFO "/tmp/fifo"int main(int argc,char *argv[])&#123; int pipe_fd; int bytes_read=0; char buffer[4096]; memset(buffer,'\0',4096); printf("PID %d opening FIFO O_WRONLY.\n",getpid()); pipe_fd=open(FIFO,O_RDONLY); printf("pipe_fd=%d.\n",pipe_fd); if(pipe_fd!=-1) &#123; bytes_read=read(pipe_fd,buffer,sizeof(buffer)); printf("read data:%s\n",buffer); &#125; printf("PID %d finished.\n",getpid()); return 0;&#125; 运行结果先在A窗口执行fifo_write，结果如下：12tao@taohi-xubuntu:~$ ./fifo_writePID 5163 opening FIFO O_WRONLY. 根据前面提到的阻塞现象，fifo_write阻塞在open()。 然后在B窗口执行fifo_read，结果如下：12345tao@taohi-xubuntu:~$ ./fifo_readPID 5165 opening FIFO O_WRONLY.pipe_fd=3.read data:helloworld!PID 5165 finished. 此时观察B窗口，不再被阻塞，结果如下：1234tao@taohi-xubuntu:~$ ./fifo_writePID 5163 opening FIFO O_WRONLY.pipe_fd=3.PID 5163 finished.]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>FIFO</tag>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信之一：无名管道PIPE]]></title>
    <url>%2F2015%2F02%2F03%2Fipc-pipe.html</url>
    <content type="text"><![CDATA[基本概念无名管道是一种特殊类型文件。内核资源对应一段特殊内存。管道的数据流是单向的。 命令ulimit -p 查看管道最大值限制，默认为8*512Byte=4KB。由limit.h的宏PIPE_BUF定义。 头文件：#include &lt;unistd.h&gt; 原型：int pipe(int pipefd[2]); 若执行成功，pipefd内将存储两个文件描述符，指向管道的两端(pipefd[0]读,pipefd[1]写);若执行失败，返回值为-1。 读写管道用系统调用read和write，默认以阻塞方式读写。 工作原理 示例代码实现管道操作ls /home/tao|sort12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;int main(int argc,char *argv[])&#123; int fd[2]; if(pipe(fd)==-1) &#123; perror("pipe"); exit(-1); &#125; if(fork() == 0)//child process.用于sort &#123; dup2(fd[0],0); close(fd[1]); execlp("sort","sort",(char *)0); &#125; else &#123; if(fork()==0)//child process.用于ls &#123; dup2(fd[1],1); close(fd[0]); execlp("ls","ls","/home/tao",(char *)0); &#125; else &#123; close(fd[0]); close(fd[1]); wait(NULL); wait(NULL); &#125; &#125; return 0;&#125; 程序说明：主进程分别fork了两个子进程，主进程产生的管道由两个子进程共享使用(管道是文件，根据进程fork的原理，父子进程共享打开的管道文件)。一个子进程执行ls，用dup2将标准输出重定向到管道写端fd[1]，另一个子进程执行sort，dup2将标准输入重定向到fd[0],于是它从管道读端fd[0]获取需要sort的数据。这样就实现了主进程的两个子进程的通信。 执行结果：和执行 ls /home/tao|sort一模一样。 可以看出，为了共享同样的文件描述符，无名管道适合这种亲缘关系接近的子进程之间通信。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
        <tag>pipe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信总述]]></title>
    <url>%2F2015%2F02%2F03%2Flinux-ipc.html</url>
    <content type="text"><![CDATA[进程是独立的资源管理单元。不同进程之间需要交互信息，这就需要进程间通信。 Linux继承了Unix和System V的进程间通信方式。Linux支持的主要进程间通信机制如下图所示。这样看起来，有8种。后续按照编号逐一介绍。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的地址映射]]></title>
    <url>%2F2015%2F02%2F02%2Flinux-address-mapping.html</url>
    <content type="text"><![CDATA[地址类型80X86的体系结构，有如下三种地址： 逻辑地址是虚拟地址空间。就是每个进程使用的独立逻辑地址，通常为4GB。逻辑地址=段选择符(16bit) + 段内偏移(32bit)。常说的逻辑地址就是这32位段内偏移。 线性地址(虚拟地址)值从0x00000000到0xffffffff 物理地址就是物理地址。 映射过程当进程引用一个逻辑地址时，需完成逻辑地址到物理地址的转换：逻辑地址–(分段)–&gt;线性地址–(分页)–&gt;物理地址 逻辑地址-(分段)-&gt;线性地址 逻辑地址有两部分：段选择符(16bit)+offset(32bit) 段描述符：每个段由一个8字节的段描述符(Segment Descriptor)表示，存放着段首地址、段长度、特权级等信息。 GDT和LDT：全局描述符表GDT，局部描述符表LDT。存放段描述符。 gdtr和ldtr：寄存器。存放GDT和LDT在内存中的地址。 转换过程： 段选择符的TI字段，确定是选gdtr或者ldtr，这就确定了段描述符表的基地址; 段选择符的index字段，来计算段描述符的地址，即index字段的值乘以8，并将这个结果与GDTR或LDTR寄存器中的内容相加，得到了对应的段描述符表。 offset与段描述符表的Base值相加，得到线性地址。 对于Linux：它只有4个段，而且对应段描述符的Base值均为0.所以offset+base=offset.得出结论：Linux下，逻辑地址等于线性地址。 线性地址-(分页)-&gt;物理地址 32位线性地址=10(页目录)+10(页表)+12(页内偏移) cr3寄存器：存放正在使用的页目录物理地址。OS进程调度时，自动将当前进程页目录物理地址存入cr3寄存器。 页目录和页表都有1024项(2的10次方)。 缺页异常:如果页目录/页表里的preset标志为0，则将产生缺页异常。将从磁盘把相应页载入内存。 对于Linux：分页过程差不多，只不过Linux使用了多级页目录而已。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>地址映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内核container_of宏]]></title>
    <url>%2F2015%2F02%2F02%2Fkernel-container-of.html</url>
    <content type="text"><![CDATA[container_of 宏：123456struct demo_struct &#123; type1 member1; type2 member2; type3 member3; type4 member4; &#125;; 同时，在另一个地方，获得了变量demo中的某一个域成员变量的指针，比如：type3 *memp=xxx此时:struct demo_struct *demop = container_of(memp, struct demo_struct, member3); 说明:member3 是结构体demo_struct的一个成员名；memp是member3的指针。返回值是指向demo_struct结构的指针。 由此，container_of实现了：根据一个结构体变量中的一个域成员变量的指针，来获取指向整个结构体变量的指针。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核模块参数]]></title>
    <url>%2F2015%2F01%2F26%2Flinux-module-param.html</url>
    <content type="text"><![CDATA[在加载模块的时候，可以向模块传递参数值，供模块内部使用。 使用方法头文件:linux/moduleparam.h程序中:12int disk_size = 1024;module_param_named(size,disk_size,int,S_IRUGO); 加载模块时:#insmod param.ko size=2048此时，模块会用size的值2048，去替换模块内部disk_size的默认值1024。 代码实例123456789101112131415161718192021#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/moduleparam.h&gt; int disk_size=1024;module_param_named(size,disk_size,int,S_IRUGO); static int __init param_init(void)&#123; printk("module init:disk_size now:%d\n",disk_size); return 0;&#125; static void __exit param_exit(void)&#123; printk("exit module.\n");&#125; module_init(param_init);module_exit(param_exit);MODULE_LICENSE("GPL"); 运行结果[root@localhost param]# insmod param.ko size=2048[root@localhost param]# dmesg[158889.935447] module init:disk_size now:2048 想要简化，使得输入参数和代码内参数同名，则使用：module_param(disk_size,int,S_IRUGO);]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的压缩与解压]]></title>
    <url>%2F2015%2F01%2F24%2Flinux-tar-command.html</url>
    <content type="text"><![CDATA[压缩、解压缩：bzip2、 gzip等打包、解包：tar 常见格式 *.gz gzip压缩的文件 *.bz2 bzip2 压缩的文件 *.tar tar程序打包的文件，未经过压缩 *.tar.gz tar程序打包的文件，经过gzip的压缩 *.tar.bz2 tar程序打包的文件，经过bzip2压缩 常用解包命令tar -zxvf filename.tar.gztar -jxvf filename.tar.bz2z：表示gzip压缩的文件j：表示bzip2压缩的文件x：表示这是解包操作；c表示是打包操作。v：显示操作的详细过程；f：指定后面的文件名字；如果要解压到指定目录：tar zxvf filename.tar.gz -C /dir 常用打包命令tar -zcvf bb.tar.gz aa.txt将aa.txt用gz压缩并打包为bb.tar.gz文件tar -jcvf bb.tar.bz2 aa.txt将aa.txt用gz压缩并打包为bb.tar.bz2文件]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的零长度数组]]></title>
    <url>%2F2015%2F01%2F23%2Fc-flexible-array.html</url>
    <content type="text"><![CDATA[零长度的数组一般见于结构体中。在Linux内核代码中比较常见。而直接声明零长度数组，例如char str[0];这是无法编译通过的。零长度的数组一般是放在结构体的最后一个成员的位置处，放在中间也是可以的。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct str1&#123; int len; int b; char s[0];&#125;; struct str2&#123; int len; char s[0]; int b;&#125;; int main()&#123; struct str1 *sp=NULL; struct str2 *sp2=NULL; printf("Before,sizeof str1:%d\n",sizeof(struct str1)); sp=(struct str1 *)malloc(sizeof(struct str1)+10); sp-&gt;len=100; sp-&gt;b=50; strcpy(&amp;sp-&gt;s[0],"abc"); puts(sp-&gt;s); printf("After,sizeof str1:%d\n",sizeof(struct str1)); printf("len:%d\t%p\n",sp-&gt;len,&amp;sp-&gt;len); printf("b:%d\t%p\n",sp-&gt;b,&amp;sp-&gt;b); printf("s:%s\t%p\n",sp-&gt;s,&amp;sp-&gt;s); printf("\nBefore,sizeof str2:%d\n",sizeof(struct str2)); sp2=(struct str2 *)malloc(sizeof(struct str2)+10); sp2-&gt;len=150; sp2-&gt;b=60; strcpy(&amp;sp2-&gt;s[0],"def"); puts(sp2-&gt;s); printf("After,sizeof str2:%d\n",sizeof(struct str2)); printf("len:%d\t\t%p\n",sp2-&gt;len,&amp;sp2-&gt;len); printf("b:%d\t%p\n",sp2-&gt;b,&amp;sp2-&gt;b); printf("s:%s\t\t%p\n",sp2-&gt;s,&amp;sp2-&gt;s); return 0;&#125; 这里的char s[0]指的是一个变长数组，有点类似指针，不过跟指针却有本质的区别： 该结构体分配内存空间时，在栈上一次性分配，是连续的。而且成员s不占结构体空间。 如果使用指针形式，改成char *ptr,则结构体分配时,ptr需要占结构体一个指针大小。结构体本身需要一次栈上分配，指针ptr所指内存需要一次堆内分配。需要2次。而且这样内存就不连续了。 结构体的大小，测试发现是8，即sizeof(int)+sizeof(int)，也就是说s指向的空间不属于结构体str,这块空间紧跟着结构体str1所代表的空间。因此对于一个struct str1 *型的指针变量申请内存有如下方法：sp=(struct str *)malloc(sizeof(struct str)+ 10);表示给s申请了10个字节的空间。 上面分析的是结构体str1，对于结构体str2，把s[0]放在了中间，因为它不占存储空间，则s和b的地址是一样的。所以对s 赋值，会将b的原值覆盖掉。 程序运行结果如下图：]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的typedef与define]]></title>
    <url>%2F2015%2F01%2F22%2Fc-typedef-define.html</url>
    <content type="text"><![CDATA[C语言的typedef是一个存储类声明说明符。是编译过程的一部分，但是并不分配存储空间。 typedef的作用定义一个标识符及关键字的别名。 typedef的用法 1.定义一般的别名例子一：typedef int * pint; 定义pint为int指针别名。则若定义:pint pa,pb; pa和pb都表示int型指针。例子二：typedef int A[10]; 定义A表示一个含10个整型的数组。则若定义 A number; number表示含10整型元素的数组，等同于int number[10]; 2.用于struct结构体别名1234typedef struct node&#123; int data; struct node *next;&#125;NODE; 则NODE node_a;等同于struct node node_a;显得方便。 3.typedef来定义与平台无关的类型假设要定义一个8字节的长整型LONGLONG：Linux下:typedef long long LONGLONG;Windows下:typedef uint_64 LONGLONG;这样不同的平台下，使用LONGLONG均没问题，修改typedef即可。 4.定义别名，简化复杂声明原声明:int *(*a[5])(int, char*);定义别名: typedef int *(*pfunc)(int,char *);之后，使用pfunc a[5]声明a即可。 typedef与define的区别typedef发生在编译中，是和int a=5这样类似的声明；define发生在预编译中，只是简单的字面上替换。举例说明：typedef int * pint; 声明pint为int *数据类型；#define pint2 int *; 简单将两者替换。pint a,b;则a和b都为整型指针,int *a和int *b；pint2 a,b;则会替换成 int *a,b;这样a是指针，b不是指针。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>typedef</tag>
        <tag>define</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的字节对齐]]></title>
    <url>%2F2015%2F01%2F21%2Fc-byte-align.html</url>
    <content type="text"><![CDATA[一、字节对齐的作用作用：便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。 对于32位机来说，CPU一次能读取32位，则4字节对齐能够使cpu访问速度提高。 比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。 二、字节对齐的原则编译器结合当前的操作系统，确定字节对齐方式。所以和编译器、操作系统都有关。 目前对齐原则： X86_32位机：windows下：K字节大小的对象，起始地址要为K的整数倍。(用GCC和VC 6.0编译器测试)Linux下：除了2字节的类型按2的整数倍对齐，都默认4字节对齐。(GCC 编译器测试) X86_64 机器：Linux和windows：K字节大小的对象，起始地址要为K的整数倍。(查资料获得) 三、代码测试测试环境: x86 32位的Linux 和windows。编译器都使用GNU GCC.测试代码:1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;typedef struct&#123; int num1; int num2; double num3;&#125;A;typedef struct&#123; int num1; double num2; int num3;&#125;B;int main()&#123; printf("char:%d\n",sizeof(char)); printf("short:%d\n",sizeof(short)); printf("int:%d\n",sizeof(int)); printf("long:%d\n",sizeof(long)); printf("float:%d\n",sizeof(float)); printf("double:%d\n",sizeof(double)); printf("long long:%d\n",sizeof(long long)); printf("sizeof(A):%d\n",sizeof(A)); printf("sizeof(B):%d\n",sizeof(B)); return 0;&#125; 32位Linux下GCC的测试结果由于Linux下GCC默认4字节对齐，那么A、B结构体的存储方式分别如下图：程序的运行结果： 32位Windows 7 下GCC的测试结果：由于windows下的原则是：K字节的对象起始地址要是K的整数倍，那么:A结构体的存储方式如下图所示,占16字节： B结构体的存储方式如下图所示,占24字节。因为num1占了4字节，num3长度为8(K=8),那么它的起始地址要为8的倍数，为了满足这个条件，所以在num1后面要留出4字节的空白。最后在num2之后，也要留4字节空白，使得结构体为24字节。这样如果分配连续的该结构体对象，才能满足下一个结构体的起始地址为24的整数倍。程序运行结果:补充用windows VC6.0编译测试，发现sizeof(B)也为24.(VC倒是不认识long long类型) 四、修改字节对齐的方式使用伪指令#pragma pack (n)，C 编译器将按照n个字节对齐。使用伪指令#pragma pack ()，恢复默认对齐方式。12345678910111213#pragma pack(1)typedef struct&#123; char num1; int num2; char num3;&#125;C;#pragma pack()typedef struct&#123; char num1; int num2; char num3;&#125;D; C、D结构体内容相同，对齐方式不同：C按照1字节对齐，则sizeof(C)=6;D默认4字节对齐，则sizeof(D)=12.]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>linux</tag>
        <tag>字节对齐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组名与指针的区别]]></title>
    <url>%2F2015%2F01%2F20%2Farray-name-and-pointer.html</url>
    <content type="text"><![CDATA[指针指针是一种地址变量，而地址则是该变量的值。 指针是左值 。举例类比：int n=5; n是变量，5是值。指针类似于n, 地址类似于5. 数组名是一个地址值，一个符号地址常量。 数组名是右值 。用来存放数组的区域是一块在栈中静态分配的内存(非static情况)，而数组名是这块内存的代表，它被定义为这块内存的首地址。数组名是地址常量。 两个疑问1.作为形参的数组，不是会被转换为指针吗？2.如果形参是一个指针，数组名可以作为实参传递给那个指针，难道不是说明了数组名是一个指针吗？ 首先，C语言之所以把作为形参的数组看作指针，并非因为数组名可以转换为指针，而是因为当初ANSI委员会制定标准的时候，从C程序的执行效率出发，不主张参数传递时复制整个数组，而是传递数组的首地址，由被调函数根据这个首地址处理数组中的内容。那么谁能承担这种“转换”呢？这个主体必须具有地址数据类型，同时应该是一个变量，满足这两个条件的，非指针莫属了。要注意的是，这种“转换”只是一种逻辑看法上的转换，实际当中并没有发生这个过程，没有任何数组实体被转换为指针实体。 第二，函数参数传递的过程，本质上是一种赋值过程。C89对函数调用是这样规定的：函数调用由一个后缀表达式(称为函数标志符, function designator) 后跟由圆括号括起来的赋值表达式列表组成，在调用函数之前，函数的每个实际参数将被复制，所有的实际参数严格地按值传递。因此，形参实际上所期望得到的东西，并不是实参本身，而是实参的值或者实参所代表的值！举个例来说，对于一个函数声明：void fun(int i);我们可以用一个整数变量int n作实参来调用fun，就是fun(n)；当然，也正如大家所熟悉的那样，可以用一个整数常量例如10来做实参，就是fun(10) ,实际上，对于形参i来说，用来声明i的类型说明符int，所起的作用是用来说明需要传递给i一个整数，并非要求实参也是一个整数变量，i真正所期望的，只是一个整数，仅此而已，至于实参是什么，跟i没有任何关系，它才不管呢，只要能正确给i传递一个整数就OK了。当形参是指针的时候，所发生的事情跟这个是相同的。指针形参并没有要求实参也是一个指针，它需要的是一个地址，谁能给予它一个地址？显然指针、地址常量和符号地址常量都能满足这个要求，而数组名作为符号地址常量正是指针形参所需要的地址，这个过程就跟把一个整数赋值给一个整数变量一样简单！ PS:部分参考出处未知的网络文章，侵删。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C指针的复杂声明]]></title>
    <url>%2F2014%2F07%2F14%2Fc-pointer-complex-declaration.html</url>
    <content type="text"><![CDATA[C语言复杂声明解读顺序 和 () * char int 等 10个解读示例1.float (*p)[2]p是一个指针，指向含有2个float元素的数组。 2.char *p[5]p是一个数组，数组含有5个字符类型的指针。 3.char (*fp)(char *,int *)fp是一个函数指针，指向的函数形参为一个字符型指针和一个整形指针，函数返回值为字符型。 4.int *pf(float (*a)(int))pf是一个指针函数，它的参数又是一个函数指针，所指向的函数带一个int形参，返回值为float型。pf返回值为整形指针。 5.int (*pf(char *))[5]pf是一个指针函数，它的参数是一个字符指针，返回值为一个指针，指针指向含5个整形元素的数组。 6.char *(*p[2])(char *,char *)p是含2个元素的指针数组，元素类型是函数指针，所指向的函数形参为两个字符指针，返回值为字符指针。 7.int (*(*pf)(char *))[3]pf是函数指针，指向的函数带一个字符指针型的参数，返回值为指向长度为3的整形数组的指针。 8.char *(*a[2])(char(*)(int *),char*)a是有2个元素的函数指针数组，数组元素指向的函数有两个形参：第一个形参为函数指针，指向一个带整形指针形参，返回值为字符指针的函数，第二个参数为字符型指针。a的数组元素指向的函数返回值为字符型指针。 9.int (*(*pf[3])(char *))(char *)pf是有3个元素的函数指针数组，每个指针所指向的函数带char *类型的形参，返回值为一个函数指针，该指针所指向的函数带一个char *形参，返回值为int型。 10.char *(*(*(*f[2])(char *))[2])(char *,char *)f是长度为2的函数指针数组，数组元素指向的函数含有一个char *形参，返回值为指向含有2个函数指针元素的数组指针，这个数组里的函数指针指向的函数带2个char *型形参，返回值为char *类型。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的sizeof运算符]]></title>
    <url>%2F2014%2F07%2F13%2Fc-sizeof.html</url>
    <content type="text"><![CDATA[sizeof说明sizeof是一个编译时(compile-time)一元运算符。用于计算任意一对象的长度。由于是编译时计算出对象的大小，因此在预编译#if等语句中不能使用。用法：sizeof 对象 或者 sizeof(类型名)运算结果：等于指定对象或者类型占用的存储字节数。所得结果类型为size_t，无符号整型。 实例代码12345678910#include &lt;stdio.h&gt;void main()&#123; int a[10]; int *p=a; printf("数组a的长度:%d\n",sizeof a/sizeof a[0]); printf("size_t的大小:%d\n",sizeof(size_t)); printf("指针p的大小:%d\n",sizeof(p)); printf("hello字符串的大小(包含'\\0'):%d\n",sizeof("hello"));&#125; 运行结果]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的const和static]]></title>
    <url>%2F2014%2F07%2F13%2Fc-const-static.html</url>
    <content type="text"><![CDATA[存储类声明符static: 局部static变量：作用域为局部函数内。函数被调用的过程中维持其值不变。已经初始化则存放在data段，未初始化则默认初始化为0，存放在bss段。 全局static变量：作用域为本文件内。已经初始化则存放在data段，未初始化则默认初始化为0，存放在bss段。 一个被声明为static的函数，只可被这一模块内的其它函数调用。其他模块文件不能访问它。 类型限定符const： 可以定义const常量。 const可以修饰函数的参数、返回值甚至函数的定义体。 被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。const int a;int const a;前两个都表示，a是一个常量整形数。const int *a;a是一个指向常整形数的指针（整形数是不可以修改的，但是指针可以）。int *const a;a是一个指向整形数据常指针（指针指向的整形数是可以修改的，但是指针是不可以修改的）int const *a const;a是一个指向常整形的常指针（指针指向的整数不可以修改，同时指针也不可以修改） C语言的const机制： 在最初的C标准中，并没有const，只是在有了C++后，才将const加入C的标准中。 在编译的过程中，编译器会检查代码中是否有对const变量进行修改的代码，如果有则向用户报错。编译过后，const变量就和普通变量相同了。而且，如果使用memset去修改const变量的内容，也完全没有问题，这就可以看出const修饰是属于编译层面的限制，一般不会涉及到运行层面。在C中，const是用于明确的标识出变量或者函数不能被修改，而且这种限制在编译层面进行约束。 对于局部const变量，存放在栈上，可以通过取地址操作，memset等进行修改； 对于全局const变量，存放在只读数据段rodata段，被操作系统保护，所以修改会引发段错误。 static和const代码：12345678910111213141516171819202122#include &lt;stdio.h&gt;static int a[3];const int b=2;void main()&#123; static int c; int i=0; while(i&lt;3) &#123; printf("global static a[%d]=%d\n",i,a[i]); i++; &#125; printf("local static c=%d\n",c); const int d=1; //局部const变量a分配在栈上，栈可以通过地址读写，所以 //可以通过地址修改a的值 int *pd= (int *)&amp;d; *pd=31; printf("local const d=%d\n",d); int *pb = (int *)&amp;b; *pb=20;//报段错误，因为全局const常量b分配在.rodata区，是只读的。&#125; 运行结果：]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>const</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的输入输出]]></title>
    <url>%2F2014%2F07%2F12%2Fc-input-output.html</url>
    <content type="text"><![CDATA[这些输入输出函数接口，全都定义在stdio.h头文件中。下面是几个变量声明12345#define MAX 1024int n;char c;char *s;char str[512]; scanf()原型:int scanf(char *format,...)返回值：成功读取的变量数目，失败返回0从标准输入读入字符序列，按照format格式存入到其余参数中。scanf(&quot;%d&quot;,&amp;n);把输入当做一个数字存入n；scanf(&quot;%[^\n]&quot;,str);把字符串读入str，直到出现换行符’\n’,这样就可以用scanf读入带空格的字符串了。 fgetc()原型:int fgetc(FILE *stream)从流stream中读一个字符。可以将标准输入stdin作为它的实参，这时候从标准输入读取一个字符。 fputc()原型:int fputc(int character, FILE *stream); getchar()原型:int getchar(void)从标准输入一次读取一个字符并返回，遇到文件尾返回EOF。#define getchar(fgetc(stdin)) putchar()原型:int putchar (int character)#define putchar(c) fputc(c, stdout) gets()原型:char * gets (char *str);从标准输入stdin读取一个字符串，遇到换行或结束时候终止。它不检查数组str的大小，容易溢出，不要使用。 puts()原型:int puts (const char *str) fgets()原型:char * fgets (char *str, int num, FILE *stream);从流stream中读入最多num个字符到字符数组str中，当遇到换行符时、或读到num-1个字符时停止。自动加上’\0’空字符结尾。这个函数常用于输入带空格的字符串。 fputs()原型:int fputs (const char *str, FILE *stream)]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C程序的汇编级别运行过程]]></title>
    <url>%2F2014%2F07%2F12%2Fc-in-disassemble-level.html</url>
    <content type="text"><![CDATA[C语言程序的执行，函数调用过程，如果将代码从汇编级别来研究，看内存中的汇编程序怎么运行，将会对C程序的执行理解更加深入。 环境：Xubuntu GCC GDB C代码1234567891011int foo(int a,int b)&#123; int c=a+b; return c;&#125; int main(void)&#123; foo(2,3); return 0;&#125; 汇编代码 main函数c与汇编对照 foo函数C与汇编对照 汇编相关知识 eip寄存器：始终存放下一条要执行的指令地址； ebp寄存器：存放当前栈基址(栈底)； esp寄存器：存放当前栈顶地址； eax ebx ecx edx是一些普通寄存器，用于参数和返回类型等； mov A B ：相当于把A处的值存入B处； call xxx：相当于push eip 且 jmp xxx； leave：相当于mov ebp esp 且 pop ebp； ret：相当于pop eip；]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>汇编</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用笔记]]></title>
    <url>%2F2014%2F07%2F10%2Fgit-usage-notes.html</url>
    <content type="text"><![CDATA[git用来做代码版本管理非常合适和高效。 安装git在ubuntu下获得git非常容易：sudo apt-get install git git提交到远程池 一次典型的过程，以在github建远程仓库为例，事先去github建立一个名字为test的repository之后：123456789git config --global user.name taohi //第一次使用git时设置git config --global user.email taohi@taohi.net //第一次时设置mkdir test &amp;&amp; cd test git init //本地仓库初始化vim hello.c git add hello.c //加入到staging areagit commit -m &quot;first file hello world&quot; //提交到本地repositorygit remote add origin git@github.com:taohi/test.git//设置origin别名git push -u origin master //提交到远程repository 当然，要事先在github上设置好本地电脑生成的ssh public key,允许本地电脑的权限。 git做一次merge管理git一般是一组人一起使用，在各自的本地repo与远程repo之间更新代码。在一定阶段后，比如说组内阶段1任务完成，此时需要将各自的分支下代码整合到master分支里。以我自己分支taohi为例，将其merge到远程master，过程如下：1234567891011git checkout master //进入本地master分支git merge taohi //把我的分支merge到master分支git checkout -t origin/xiaoming //取远程xiaoming的分支到我本地git pullgit checkout mastergit merge xiaoming //把小明的分支merge到master下 //如果还有其他人的分支，按上述方法都进行合并git push origin master //把本地最后合并好的master更新到远程池git tag topic1git push origin --tags结束。 git撤销一次merge合并我在master下手贱，merge了一个分支。马上想撤销这次merge。先git log 查看要撤销的这个merge操作的commit 编号，假设是fb10e4694ccc21321。执行：git reset --hard fb10e4694ccc21321。 git更换远程库地址比如之前用的github的库，地址为url-github现在用bitbucket的库，地址为url-bitbucket.123456git remote rm origingit remote add origin url-bitbucketgit push origin master``` ## git的其他常用命令 git ls-remote 查看远程所有的分支git remote -v 查看git远程详细地址git reset HEAD ^ 回滚到上一个提交点。注意上尖号git branch (branch_name) 查看(创建)分支git checkout branch_name 进入某分支`]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下C程序的内存布局]]></title>
    <url>%2F2014%2F07%2F10%2Flinux-c-memory-layout.html</url>
    <content type="text"><![CDATA[C可执行程序的结构C程序语言在编译和连接后，生成可执行程序，作为文件存放在磁盘上它的结构如下: 1.代码段Text2.只读数据段RO Data3.读写数据段RW Data 其中RO Data和RW Data统称为初始化数据段initialized data。在可执行程序载入运行时，会产生地址映射，以上三部分会对应到程序的虚拟地址空间。除了以上三个区域外，还产生: 4.未初始化数据段BSS区域5.堆Heap区域6.栈Stack区域 各部分含义1.代码段(Code或Text)从0x08048000虚拟地址开始。代码段由程序中执行的机器代码组成。在C语言中，程序语句进行编译后，形成机器代码。在执行程序的过程中，CPU的程序计数器指向代码段的每一条机器代码，并由处理器依次运行。 2.只读数据段(RO data)存放const 常量，字符串常量等。使用这些数据的方式类似查表式操作，由于这些变量不需要更改，因此只需要放置在只读存储器中即可。 3.已初始化读写数据段(RW data)存放已初始化全局变量和static变量，这些变量需要占用存储空间，具有初值，供程序运行时读写。 4.未初始化数据段(BSS)存放未初始化全局变量和static变量。这些变量在程序运行之前，不占用存储空间。 5.堆(heap)堆内存只在程序运行时出现，一般由程序员分配和释放，比如malloc.在具有操作系统的情况下，如果程序没有释放，操作系统可能在程序(例如一个进程)结束后回收内存。 6.栈(stack)从0xC0000000开始往下低地址增长。栈内存只在程序运行时出现，在函数内部使用的变量、函数的参数以及返回值将使用栈空间，栈空间由编译器自动分配和释放。栈大小在linux下可以使用ulimit -s查看，linux默认8M。可以修改，比如：用ulimit -s 4096指定为4M。如果程序用栈太大就出现栈溢出，程序出现段错误并退出。比如无限递归。 示例代码分析12345678910111213141516171819const char ro[] = &#123;"this is read only data"&#125;; //只读数据区static char rw_1[] =&#123;"this is global read write data"&#125;; //已初始化读写数据段char BSS_1[ 100]; //未初始化数据段const char *ptrconst ="constant data"; //字符串放在只读取数据段int main()&#123; short b; //在栈上，占用2个字节 char a[100]; //在栈上开辟100个字节， 它的值是其首地址 char s[]="abcdefg"; //s在栈上，占用4个字节，"abcdefg"本身放置在只读数据区，占8个字节 char *p1; //p1在栈上，占用4个字节 char *p2="123456"; //p2 在栈上，p2指向的内容不能改，“123456”在只读数据区 static char rw_2[]=&#123;"local read write data"&#125;;//已初始化读写数据段 static char BSS_2[100]; //未初始化数据段 static int c = 0; //全局(静态)初始化区 p1=(char *)malloc(10 * sizeof(char)); //分配内存区域在堆区 strcpy(p1,"xxxx"); //“XXXX”放在只读数据区，占5个字节 free(p1); //使用free释放p1所指向的内存 return 0;&#125; 内存布局图]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>linux</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下gcc的编译流程]]></title>
    <url>%2F2014%2F07%2F08%2Fgcc-work-flow.html</url>
    <content type="text"><![CDATA[基本概念在linux系统上，从源文件到目标文件的转化是由编译器完成的。以hello.c程序的编译为例，如下:1tao@tao-R408P~$ gcc -o hello hello.c 在这里，gcc编译器读取源文件hello.c，并把它翻译成一个可执行文件 hello。这个翻译过程可分为四个阶段逐步完成 :预处理，编译，汇编，链接，如下图所示。 详细分析在未编译前，hello.c 的源代码如下：123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello, world\n&quot;); return 0;&#125; 第一步：预处理阶段执行命令: gcc -o hello.i -E hello.c或者执行： cpp -o hello.i hello.c (这里cpp不是值c plus plus,而是预处理器the C Preprocessor) 预处理器cpp根据以字符开头#开头的命令，修改原始C程序：比如hello.c中的第一行为 #include，预处理器便将stdio.h的内容直接插入到程序中。预处理之后得到文本文件hello.i，打开如下：1234567891011121314# 1 &quot;hello.c&quot;# 1 &quot;&quot;# 1 &quot;&lt;命令行&gt;&quot;# 1 &quot;hello.c&quot;# 1 &quot;/usr/include/stdio.h&quot; 1 3 4...extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));# 943 &quot;/usr/include/stdio.h&quot; 3 4# 2 &quot;hello.c&quot; 2int main()&#123; printf(&quot;hello, world\n&quot;); return 0;&#125; 在源代码的前面插入了stdio.h，整个hello.i 的行数由hello.c的6行变到了849行. 第二步：编译阶段执行命令: gcc -o hello.s -S hello.i或者执行：ccl -o hello.s hello.i编译器ccl 将文本文件hello.i 翻译为hello.s，这个文件里面包含一个汇编程序，如下：1234567891011121314151617181920212223242526272829.file &quot;hello.c&quot; .section .rodata.LC0: .string &quot;hello world&quot; .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushl %ebp .cfi_def_cfa_offset 8 .cfi_offset 5, -8 movl %esp, %ebp .cfi_def_cfa_register 5 andl $-16, %esp subl $16, %esp movl $.LC0, (%esp) call puts movl $0, %eax leave .cfi_restore 5 .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size main, .-main .ident &quot;GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 汇编语言是非常有用的，因为它给不同高级语言的不同编译器提供了通用的输出语言。例如，C和Fortran 的在此步编译产生的输出文件都是一样的汇编语言。 第三步：汇编阶段执行命令: gcc -o hello.o -c hello.s或者执行： as -o hello.o hello.s汇编器as 将hello.s 翻译成机器语言保存在hello.o 中。这是个二进制文件 第四步：链接阶段执行命令: gcc -o hello hello.o或者执行： ld -o hello hello.o注意：hello程序调用了printf 函数，这个函数是标准C库中的一个函数，他保存在一个名为printf.o 的文件中，这个文件必须以某种方式合并到我们的hello.o的程序中。链接器ld 负责处理这种合并。结果得到hello 可执行文件，可以被加载到内存中由系统执行。 最后总结编译器的编译过程:源文件–&gt;预处理–&gt;编译/优化–&gt;汇编–&gt;链接–&gt;可执行文件。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试器基本使用]]></title>
    <url>%2F2014%2F07%2F08%2Fgdb-debug-md.html</url>
    <content type="text"><![CDATA[常用命令 gcc -g a.c -o a.out，这样就可以调试a.out gdb a.out开始调试a.out focus 类似turbo C的界面，使得当前代码高亮实时显示。 list 15 从15行开始列出源码 b foo() 在foo()函数设置断点 b 20 在第20行设置断点 r 表示跑程序，run n 表示next，单步执行 display 变量一直显示某变量的值 p 变量 打印一次某变量的值 p *地址 打印内存某地址里的内容 info args 查看参数信息 汇编相关 layout asm 显示汇编代码 start 开始单步运行 disassemble 函数名 显示某函数的汇编代码 disassemble /m 显示当前函数汇编代码 si 表示step into，按汇编语句单步执行，深入被调函数 ni 表示step over，也是单步执行； info registers 查看所有寄存器的值 display $eax这样查看寄存器值 info frame 查看当前栈的概览信息 x/10x $sp按照16进制打印当前栈的前10个元素]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>debug</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法C实现]]></title>
    <url>%2F2014%2F07%2F08%2Fsort-code-in-c.html</url>
    <content type="text"><![CDATA[排序的方法非常多，这篇博客进行总结。关键、常用的排序方法： 快速排序，提高效率的方法 堆排序 递归归并排序 非递归归并排序 下面是这些排序的代码,C语言实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a,int i,int j)&#123; int temp; temp=a[i]; a[i]=a[j]; a[j]=temp;&#125;//O(n**2) Stablevoid bubble_sort(int *a,int n)&#123; int i,j,temp; for (i=0;i&lt;n;i++) &#123; for(j=i+1;j&lt;n;j++) if(a[i]&gt;a[j]) swap(a,i,j); &#125;&#125;//O(n**2) Not Stable//和冒泡类似，只是减少了盲目交换的次数。void select_sort(int *a,int n)&#123; int i,j,k,temp; for(i=0;i&lt;n-1;i++) &#123; k=i; for(j=i+1;j&lt;n;j++) if(a[k]&gt;a[j]) k=j; if(i!=k) swap(a,i,k); &#125;&#125;//O(nlogn) Not stablevoid quick_sort(int *a,int left,int right)&#123; int last=left; int i; if(left&gt;=right) return ; swap(a,left,(left+right)/2); for(i=left+1;i&lt;=right;i++) if(a[i]&lt;a[left]) swap(a,++last,i); swap(a,left,last); quick_sort(a,left,last-1); quick_sort(a,last+1,right);&#125;//O(n**2) Stablevoid insertion_sort(int *a,int n)&#123; int i,j,temp; for(i=1;i&lt;n;i++) &#123; temp=a[i]; j=i-1; while(j&gt;=0 &amp;&amp; temp&lt;a[j]) &#123; a[j+1]=a[j]; j--; &#125; a[j+1] = temp; &#125;&#125;//O(nlogn) Not stablevoid shell_insert_sort(int *a,int n)&#123; int gap,i,j,temp; for(gap=n/2;gap&gt;0;gap/=2) for(i=gap;i&lt;n;i++) for(j=i-gap;j&gt;=0 &amp;&amp; a[j]&gt;a[j+gap];j-=gap) swap(a,j,j+gap);&#125;//O(nlogn) Not stable. O(1) spare space.void heap_adjust(int *a,int i,int n)&#123; int child,temp; for(temp=a[i];2*i+1 &lt; n;i=child) &#123; child = 2*i +1; if(child!=n-1 &amp;&amp; a[child+1]&gt;a[child]) ++child; if(temp &gt;= a[child]) break; a[i]=a[child]; &#125; a[i]=temp;&#125;void heap_sort(int *a,int n)&#123; int i; for(i=n/2 -1;i&gt;=0;i--) heap_adjust(a,i,n); for(i=n-1;i&gt;0;i--) &#123; swap(a,0,i); heap_adjust(a,0,i); &#125;&#125;void merge(int *array,int left,int m,int right)&#123; int i,j,k=0,l; //merged动态临时数组,将有序的array[left...m]和有序的array[m+1...right] //归并成新的有序数组存放到merged中 int *merged=(int *)malloc(sizeof(int)*(right-left+1)); // printf("merge--[%d %d] [%d %d]\n",left,m,m+1,right); for(i=left,j=m+1;i&lt;=m &amp;&amp; j&lt;=right;k++) &#123; if(array[i]&lt;=array[j]) merged[k]=array[i++]; else merged[k]=array[j++]; &#125; //如果比较完后，前半部分还有剩的，直接接到merged后面 if(i&lt;=m) &#123; for(;i&lt;=m;k++) merged[k]=array[i++]; &#125; //如果比较完后，后半部分还有剩的，直接接到merged后面 if(j&lt;=right) &#123; for(;j&lt;=right;k++) merged[k]=array[j++]; &#125; //将有序的merged拷贝到原始array[left...right] for(l=left,k=0;l&lt;=right;l++) array[l]=merged[k++]; free(merged);&#125;//归并排序，递归版本//O(nlogn) Stable. spare space O(n+logn)void merge_sort_rec(int *a,int left,int right)&#123; int i=0; if(left&lt;right) &#123; i=(left + right)/2; merge_sort_rec(a,left,i); merge_sort_rec(a,i+1,right); merge(a,left,i,right); &#125;&#125;//归并排序，非递归版(推荐)void merge_sort(int *a,int left,int right)&#123; int i=0,k=2; //数组的长度=right+1 //k是归并时增长的步长 while(k&lt;=right+1) &#123; i=0; //内while循环归并后的序列长度为k while(i+k&lt;=right+1) &#123; //printf("merge(%d,%d,%d)\n",i,i+k/2-1,i+k-1); merge(a,i,i+k/2-1,i+k-1); i+=k; &#125; //如果剩下两个子序列,他们肯定不够while里的归并长度，在这里把他们归并 //如果不剩(i==right)或者只剩一个子序列(i+k/2-1==right)，什么也不用做 if(i+k/2-1&lt;right) &#123; merge(a,i,i+k/2-1,right); //printf("merge(%d,%d,%d)\n",i,i+k/2-1,right); &#125; k*=2; &#125; //最后一次归并 //printf("last merge(%d,%d,%d)\n",left,k/2-1,right); merge(a,left,k/2-1,right);&#125;void print(int *a,int n)&#123; int i; for(i=0;i&lt;n;i++) printf("%5d",a[i]); printf("\n");&#125;void main()&#123; int a1[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a2[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a3[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a4[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a5[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a6[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a7[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a8[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; bubble_sort(a1,10); print(a1,10); select_sort(a2,10); print(a2,10); quick_sort(a3,0,9); print(a3,10); insertion_sort(a4,10); print(a4,10); shell_insert_sort(a5,10);print(a5,10); heap_sort(a6,10); print(a6,10); merge_sort_rec(a7,0,9); print(a7,10); merge_sort(a8,0,9); print(a8,10); //如果排序前要手动获得数组长度，用sizeof： //printf("Array a1 length =%d\n",sizeof(a1)/sizeof(a1[0]));&#125;]]></content>
      <categories>
        <category>数据结构算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试笔试题目]]></title>
    <url>%2F2014%2F07%2F08%2Finterview-questions.html</url>
    <content type="text"><![CDATA[百度实习1面 堆和栈的区别 malloc的底层机制？ 进程和线程的区别 进程之间有哪些通信方式 如何创建共享内存？通过malloc吗？ 知道哪些排序算法？它们的稳定性和复杂度怎样？为什么快排的平均时间复杂度是O(nlgn)？ 算法题：两个字符串s1和s2，判断s2是否是s1的旋转字符串。 问我有什么问题要问他的？ 百度实习2面 2014年5月5日 typedef定义一个含有10个整型数的数据类型；typedef int x[10]; 怎么根据数组名字求数组长度；sizeof(a)/sizeofsizeof(a[0]); 写代码。查看某个值在不在给定二叉树中；递归函数实现; 写代码，按顺序输出二叉排序树的各个节点值；递归函数实现； 海量日志，含有关键字，几亿条，关键字有重复，内存放不下，输出重复率最高的前100个关键字（hash切割小文件+hash_map统计频率+堆排序输出）; SSD的分类，优缺点，损耗均衡的实现；为啥要自己实现驱动，不是用linux提供的？（MLC 和SLC ，MLC寿命短，密度高，SLC寿命长，密度低。）; 对面向对象的理解，（不会c++，举例linux内核关于文件系统的实现inode，dentry等，C语言实现面向对象的思想）; static关键字的各种用法以及区别. 百度广告优化部面试 2014年5月27日下午 人生规划，未来2年规划，方向。谈N久，扯。 百度搜索风云榜刚过去的一天，query热点统计，时间滑动窗口； 设计一个类，含有push pop 和min求最小值功能，使得这几个操作时间复杂度为O(1)。 他讲他们的日常工作。 单链表打印倒数第K个节点值。 网易游戏研发一面 2014年6月11日下午 SSD项目各种，会不会C++； 内存地址映射。虚拟地址–&gt;逻辑地址–&gt;物理地址映射的详细实现过程； static关键字的作用，声明的变量与普通变量的区别，如何在工程里若干个文件里共享全局变量，工程生成可执行目标的过程； 递归要注意的事项，递归如果无限下去会怎么办，递归的栈没了会怎么样，等等； 函数调用过程中，汇编级别是如何完成的，函数如何被调用，入栈，指令计数器怎么工作； 单项链表反转，完全写代码说出来；电话面试写代码讲述很烦。 判断两个单项链表是否有公共节点。要求：只遍历一次，不用额外空间，考虑环。 如何判断链表是否存在环； 时间不够了，结束。 网易游戏研发二面 时间：2014年6月18日下午 项目，SSD的垃圾回收，如何判断是不是垃圾。会不会c++； 生成exe过程，C代码变成汇编代码的详细过程，编译原理你学过吗？ 进程里的多线程的栈是共享的吗？堆是共享的吗？ 进程如果malloc很大一个内存块，会发生什么？ 递归栈溢出你怎么办？ 如何把递归转换成非递归呢？ C++ STL库你知道吗？ 可执行文件在内存中的布局； 重点问题：2D平面，怪物很多，静止不动。一架飞机，在飞，一边丢炸弹，炸怪物。知道炸弹的坐标，爆炸半径，知道所有怪物的坐标（存放在数组中），那么如何判断这个炸弹能炸死哪些怪物？（分区间排序。他说四叉树？？） 告诉我游戏开发，引擎用C++，逻辑用python和Lua等； 问我实习时间。有没有其他offer。]]></content>
      <categories>
        <category>面试笔试</category>
      </categories>
      <tags>
        <tag>面试笔试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[什么也没有…]]></content>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[所有标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
