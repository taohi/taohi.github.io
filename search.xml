<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Make和makefile]]></title>
    <url>%2F2019%2F03%2F27%2Fmakefile.html</url>
    <content type="text"><![CDATA[一、Make的概念Make这个词，英语的意思是”制作”。Make命令直接用了这个意思，就是要做出某个文件。比如，要做出文件a.txt，就可以执行下面的命令。 1$ make a.txt 但是，如果你真的输入这条命令，它并不会起作用。因为Make命令本身并不知道，如何做出a.txt，需要有人告诉它，如何调用其他命令完成这个目标。 比如，假设文件 a.txt 依赖于 b.txt 和 c.txt ，是后面两个文件连接cat命令的产物。那么，make 需要知道下面的规则。12a.txt: b.txt c.txt cat b.txt c.txt &gt; a.txt 也就是说，make a.txt 这条命令的背后，实际上分成两步：第一步，确认 b.txt 和 c.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。 像这样的规则，都写在一个叫做Makefile的文件中，Make命令依赖这个文件进行构建。Makefile文件也可以写为makefile， 或者用命令行参数指定为其他文件名。123$ make -f rules.txt# 或者$ make --file=rules.txt 上面代码指定make命令依据rules.txt文件中的规则，进行构建。 总之，make只是一个根据指定的Shell命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。 二、Makefile文件的格式构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。 2.1 概述Makefile文件由一系列规则rules构成。每条规则的形式如下。12&lt;target&gt; : &lt;prerequisites&gt; [tab] &lt;commands&gt; 上面第一行冒号前面的部分，叫做”目标”target，冒号后面的部分叫做”前置条件”prerequisites；第二行必须由一个tab键起首，后面跟着”命令”commands。 “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。 2.2 目标target一个目标target就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。 除了文件名，目标还可以是某个操作的名字，这称为”伪目标”phony target。 12clean: rm *.o 上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标”，作用是删除对象文件。 1$ make clean 但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。 为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。 123.PHONY: cleanclean: rm *.o temp 声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看手册。 如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 $ make上面代码执行Makefile文件的第一个目标。 2.3 前置条件prerequisites前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新前置文件的last-modification时间戳比目标的时间戳新，”目标”就需要重新构建。12result.txt: source.txt cp source.txt result.txt 上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么make result.txt可以正常运行，否则必须再写一条规则，来生成 source.txt 。 12source.txt: echo "this is the source" &gt; source.txt 上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用make source.txt，它都会生成。 12$ make result.txt$ make result.txt 上面命令连续执行两次make result.txt。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动时间戳晚于 result.txt，就不会执行任何操作，result.txt 也不会重新生成。 如果需要生成多个文件，往往采用下面的写法。 1source: file1 file2 file3 上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。 $ make source执行make source命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。123$ make file1$ make file2$ make file3 2.4 命令commands命令(commands)表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。 每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。123.RECIPEPREFIX = &gt;all:&gt; echo Hello, world 上面代码用.RECIPEPREFIX指定，大于号&gt;替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。但一般用默认的tab。 需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。123var-lost: export foo=bar echo "foo=[$$foo]" 上面代码执行后(make var-lost)，取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。12var-kept: export foo=bar; echo "foo=[$$foo]" 另一个解决办法是在换行符前加反斜杠转义。 123var-kept: export foo=bar; \ echo "foo=[$$foo]" 最后一个方法是加上.ONESHELL:命令。1234.ONESHELL:var-kept: export foo=bar; echo "foo=[$$foo]" 三、Makefile文件的语法3.1 注释井号(#)在Makefile中表示注释。 1234# 这是注释result.txt: source.txt # 这是注释 cp source.txt result.txt # 这也是注释 3.2 回声(echoing)正常情况下，make会打印每条命令，然后再执行，这就叫做回声(echoing)。12test: # 这是测试 执行上面的规则，会得到下面的结果。 12$ make test# 这是测试 在命令的前面加上@，就可以关闭回声。12test: @# 这是测试 现在再执行make test，就不会有任何输出。 由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。123test: @# 这是测试 @echo TODO 3.3 通配符通配符wildcard用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号、问号？和 […] 。比如， .o 表示所有后缀名为o的文件。 12clean: rm -f *.o 3.4 模式匹配Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。12345%.o: %.c等同于下面的写法。f1.o: f1.cf2.o: f2.c 使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 3.5 变量和赋值符Makefile 允许使用等号自定义变量。 123txt = Hello Worldtest: @echo $(txt) 上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。 调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 12test: @echo $$HOME 有时，变量的值可能指向另一个变量。v1 = $(v2)上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展静态扩展，还是在运行时扩展动态扩展？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。 为了解决类似问题，Makefile一共提供了四个赋值运算符 =、:=、？=、+=，它们的区别请看StackOverflow。1234567891011VARIABLE = value# 在执行时扩展，允许递归扩展。VARIABLE := value# 在定义时扩展。VARIABLE ?= value# 只有在该变量为空时才设置值。VARIABLE += value# 将值追加到变量的尾端。 3.6 内置变量Implicit VariablesMake命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见手册。 12output: $(CC) -o output input.c 3.7 自动变量Automatic VariablesMake命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。 $@指代当前目标，就是Make命令当前构建的那个目标。比如，make foo的 $@ 就指代foo。12a.txt b.txt: touch $@ 等同于下面的写法。1234a.txt: touch a.txtb.txt: touch b.txt $&lt;指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。12a.txt: b.txt c.txt cp $&lt; $@ 等同于下面的写法。12a.txt: b.txt c.txt cp b.txt a.txt $?指代比目标更新的所有前置条件，以空格分隔。比如规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 $^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 $*指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。 $(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 $(&lt;D) 和 $(&lt;F)$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。 所有的自动变量清单，请看手册。下面是自动变量的一个例子。123dest/%.txt: src/%.txt @[ -d dest ] || mkdir dest cp $&lt; $@ 上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件src/%.txt， $@ 指代目标文件dest/%.txt。 3.8 判断和循环Makefile使用 Bash 语法，完成判断和循环。 12345ifeq ($(CC),gcc) libs=$(libs_for_gcc)else libs=$(normal_libs)endif 上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。 12345678910LIST = one two threeall: for i in $(LIST); do \ echo $$i; \ done# 等同于all: for i in one two three; do \ echo $i; \ done 上面代码的运行结果。123onetwothree 3.9 函数Makefile 还可以使用函数，格式如下。123$(function arguments)# 或者$&#123;function arguments&#125; Makefile提供了许多内置函数，可供调用。下面是几个常用的内置函数。 shell 函数shell 函数用来执行 shell 命令1srcfiles := $(shell echo src/&#123;00..99&#125;.txt) wildcard 函数wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。1srcfiles := $(wildcard src/*.txt) subst 函数subst 函数用来文本替换，格式如下。1$(subst from,to,text) 下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。1$(subst ee,EE,feet on the street) 下面是一个稍微复杂的例子。1234567comma:= ,empty:=# space变量用两个空变量作为标识符，当中是一个空格space:= $(empty) $(empty)foo:= a b cbar:= $(subst $(space),$(comma),$(foo))# bar is now `a,b,c'. patsubst函数patsubst 函数用于模式匹配的替换，格式如下。1$(patsubst pattern,replacement,text) 下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。1$(patsubst %.c,%.o,x.c.c bar.c) 替换后缀名替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。1min: $(OUTPUT:.js=.min.js) 上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。 四、隐含规则Makefile中隐含约定了，不需要我们再明写出的规则,叫隐含规则。比如Makefile能自动推导，把.c 文件编译成.o文件。前提是这些后缀在后缀列表中。.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el 模式规则可以使用模式规则来定义一个隐含规则。模式规则的目标和目标依赖都含有%12%.o:%.c $(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@ 上面这个例子表示了,把所有的 .c 文件都编译成 .o 文件。 老式后缀规则后缀规则一般使用双后缀的方式。这种方式过时了，建议使用模式规则。12.c.o: $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt; 这个就等价于模式规则%.o:%.c ，表示把c文件编译成o文件。 后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。而要让make知道一些自定义的后缀，我们可以使用伪目标 .SUFFIXES 来定义或是删除。12.SUFFIXES: # 删除默认的后缀.SUFFIXES: .ec .c .o .h # 定义自己的后缀 五、Makefile 的实例执行多个目标12345678910.PHONY: cleanall cleanobj cleandiffcleanall : cleanobj cleandiff rm programcleanobj : rm *.ocleandiff : rm *.diff 上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标cleanall，删除所有指定类型的文件。 编译C语言项目12345678910111213141516edit : main.o kbd.o command.o display.o cc -o edit main.o kbd.o command.o display.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h cc -c display.cclean : rm edit main.o kbd.o command.o display.o.PHONY: edit clean]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>Make</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux性能分析调优基础]]></title>
    <url>%2F2019%2F03%2F07%2Fperformance-analysis.html</url>
    <content type="text"><![CDATA[vmstat全称为virtual memory stat,它能打印内存使用情况。vmstat 1 10 表示每秒采集一次系统状态，采集10次。1234567891011procs -----------memory---------- ---swap-- -----io---- -system-- -----cpu------ r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 1202464 181668 224852 2814124 0 0 10 15 0 0 8 10 81 0 0 0 0 1202464 181684 224852 2814124 0 0 0 0 431 635 1 0 99 0 0 9 0 1202464 181808 224852 2814124 0 0 0 0 428 730 1 0 100 0 0 0 0 1202464 181808 224852 2814124 0 0 0 0 722 1182 1 0 99 0 0 0 0 1202464 181800 224852 2814124 0 0 0 112 384 652 0 0 100 0 0 0 0 1202464 181800 224852 2814124 0 0 0 36 555 857 1 0 99 0 0 0 0 1202464 181800 224852 2814128 0 0 0 0 423 653 1 0 100 0 0 0 0 1202464 181800 224852 2814128 0 0 0 0 483 708 0 1 99 0 0 0 0 1202464 181800 224852 2814132 0 0 0 0 555 850 0 0 100 0 0 r: The number of processes waiting for run time.b: The number of processes in uninterruptible sleep.swpd: the amount of virtual memory used.free: the amount of idle memory.si: Amount of memory swapped in from disk (/s).so: Amount of memory swapped to disk (/s).bi: Blocks received from a block device (blocks/s).bo: Blocks sent to a block device (blocks/s).in: 每秒中断次数，包括时钟终端。cs: 每秒上下文切换次数。us: 用户态时间sy: 内核态时间id: CPU空闲时间wa: IO等待时间 dmesgdmesg|tail -n 50查看最近50条系统消息。通过这个能往往看出一些报错。 mpstatmpstat -P ALL 1按照单个CPU显示各种负载。如果发现某个cpu负载大，而其他比较空闲则值得注意。]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>strace</tag>
        <tag>mpstat</tag>
        <tag>vmstat</tag>
        <tag>top</tag>
        <tag>sar</tag>
        <tag>free</tag>
        <tag>dmesg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python十分钟起飞]]></title>
    <url>%2F2019%2F02%2F19%2Fpython-basic.html</url>
    <content type="text"><![CDATA[1.前提知识文件开头#!/usr/bin/python指定编译器。指定的编译器会来解释该python文件。# -*-encoding:utf-8 -*-指定文件用utf-8编码。 保留字and assert break class continue def del elif elseexcept exec finally for from global if import in islambda not or pass print raise return try while with yield 缩进和语句缩进用Tab，严格要求。语句结束没有分号，利用缩进标识一个语句。 查找帮助文档python文档方便、丰富，主要通过dir 和help查看帮助文档。例子：查阅列表 dir(list),看到列表有extend方法，继续查看：help(list.extend) 其他注释语句用#开头；引用使用成对的单引号、双引号、三引号标识；单行多语句，用分号隔开。 2.动态类型python的变量使用前不需要声明，这是python动态类型的体现。&gt;&gt;&gt;a=3变量a和数值对象3存储在内存中不同位置，a是对3的引用。类型与对象相关，与变量无关。 共享引用和在原处修改：有时为了避免引用同一对象，需要使用完全的拷贝。python里达到拷贝的方法有如下： 分片表达式L[:]能够复制整个序列。 字典的copy方法D.copy()复制字典。 copy标准库模块能够生成拷贝。 3.操作符优先级 4.数据类型python主要的内置数据类型有：数字、字符串、列表、元组、字典、文件，等。字符串、列表、元组都属于序列。通用的序列操作都适用。假如s=&quot;SLICEOFSPAM&quot; s2=&quot;1234&quot;通用序列操作如下：索引和分片：&gt;&gt;&gt; s[0:3]‘SLI’字符串反转：&gt;&gt;&gt; s[::-1]‘MAPSFOECILS’ 分片图示如下： 字符串字符串是不能修改的。 字符串格式化123&gt;&gt;&gt; "%s,open the %s"%("Bob","door")'Bob,open the door'&gt;&gt;&gt; 字符串转义比如open(&#39;C:\new\test.txt&#39;,r) 会被识别为含有换行符和制表符。为了正常使用，有两个办法：可以转义：open(&#39;C:\\new\\test.txt&#39;,r)也可以raw字符串：open(r&#39;C:\new\test.txt&#39;,r)raw字符串：如果字母r出现在字符串的第一个引号前面，那么就关闭\的转义机制。 常见的字符串操作 常见字符串方法 5.列表字典和元组列表用中括号表示。L=[12,&#39;ab&#39;,3]可以用list建立列表：list(&quot;Hello&quot;) 列表基本操作 字典用大括号表示。以键值对(key:value)的形式出现。字典用key来索引。d={&quot;Hubei&quot;:&quot;Wuhan&quot;,&quot;Jiangsu&quot;:&quot;Nanjing&quot;}可以用dict创建字典:dict([(&#39;age&#39;:42),(&#39;name&#39;:&#39;Bob&#39;)]) 字典基本操作 元组用小括号表示。元组内容不可变。 元组常用操作 6.控制语句if语句例子：123456if a&lt;10: print "a&lt;10"elif a&gt;10: print "a&gt;10"else: print "a=10" for语句例子：12for x in range(0,5): print x while语句例子：1234x=0while x &lt;10: x+=1print x 这些控制语句都是可以迭代的。pass语句：空语句，什么也不做。相当于C语言里的分号语句。另外还有，continue语句，break语句等。 7.函数python7.1 函数示例1234def add(a,b): 'This is an add function.' return a+bprint add(3,5) 函数说明档是字符串；函数返回值可有可无； 7.2 参数作用域函数内为参数赋予新值，不改变外部变量的值。123456789101112def hello(name): name = 'Bob' print "hello,",name name = "Jim"hello(name) print ('Now name is:%s')%name---python output---hello, Bob Now name is:Jim ------------------- 但是，如果参数引用的是一些列表，字典等，就会改变结果。 12345678910def hello(names): names[0] = 'Bob' print "In func,names:",namesnames_all = ['Jim','Alice','Dav']hello(names_all)print 'out:',names_all-----python output-----In func,names: ['Bob', 'Alice', 'Dav'] out: ['Bob', 'Alice', 'Dav']----------------------- 当两个变量同时引用一个列表，实际是操作的同一个列表。局部变量与全局变量同名：函数内改变局部变量值，不影响全局变量。如果函数内要访问全局变量，使用global标识全局变量名。 7.3 参数位置和默认值123456789101112def hello(name,greeting="Ni hao"): print "%s,%s!"%(greeting,name) hello(name='David') hello('Bob',"Hi") hello("Alice") hello(name="Annie",greeting="hey")---------- python output----Ni hao,David! Hi,Bob! Ni hao,Alice! hey,Annie! ------------------------- 函数定义里，无默认值的形参在前。 函数调用时，传参方法多种。见代码 7.4参数传递普通参数：123456def param_show(*param): print param param_show(12,'ab',3.21)-------- python ---------- (12, 'ab', 3.21) ---------------------------- 这样参数放在元组里传递进来。 关键字参数：123456def param_show(**param): print param param_show(a=12,b=15,c=20)---------- python ---------- &#123;'a': 12, 'c': 20, 'b': 15&#125; ---------------------------- 关键字参数作为字典传递进来。 7.5 匿名函数lambda&gt;&gt;&gt;x=lambda a,b,c:a+b+c &gt;&gt;&gt;x(&quot;He&quot;,&quot;is&quot;,&quot;dog&quot;) &gt;&gt;&gt;He is dog 8.捕捉异常python详细：先import exceptions，再help(exceptions) 最常见形式：123456try: x=10 y=0 print x/y except ZeroDivisionError: print "Divisor can't be zero." 在try里执行，在exception里捕捉异常，进行处理。 很完整的用法：1234567891011#-*-encoding:utf-8 -*- try: import xxmodule print y except (ImportError,NameError),e: print "Nothing serious.",e raiseelse: print "else clause"finally: print "finally clause" 有异常： try–&gt;excecpt–&gt;finally 没有异常：try–&gt;else–&gt;finally except(ImportError,NameError)可以捕捉两个异常之一，但是只捕捉最先引发的异常。except 后面加e，可以将系统异常信息存储，打印出来。捕捉并处理了异常后，仍可将该异常再次引发，在try语句块执行完后，系统会处理。 异常是python的一个类object，各种触发的异常都是exceptions子类的实例。 下面是运行结果：1234567---------- python ----------Nothing serious. No module named xxmodulefinally clauseTraceback (most recent call last): File &quot;exceptions.py&quot;, line 3, in &lt;module&gt; import xxmoduleImportError: No module named xxmodule 9.文件操作python详细文档：help(file) 9.1读操作123456f=open("data.txt",'r') #读方式打开文件 f.read(4) #读4个字符 text=f.readlines() #按行读出所有内容,每行为一个列表元素。 for line in text： print textf.close() #关闭文件 9.2写操作12345f=open("data.txt",'w')# 常用r+以读写方式打开文件 f.seek(5) #定位起始写入位置f.write("hello,world")f.writelines(["first line","second line."]) #把列表元素按行写入文件f.close() #显式关闭，确保数据刷到硬盘 9.3文件迭代器12for line in open("data.txt"): print line #可以不用关闭 10.类和面向对象 python类class：是实例instance的生产工厂。类方法：class顶层定义的函数。类属性：class顶层定义的变量。实例属性：类方法中赋给self的属性。self参数：类方法函数的第一个参数，它代表具体的实例对象。init:构造器：实例创建时，python就会调用它。继承搜索顺序：1，实例对象；2，创建实例的类；3，对象树较高的超类，从左至右。 示例代码：123456789101112131415161718192021222324#encoding=utf-8class human(): #超类定义 def __init__ (self,legs): #构造器 self.legs = 2 #实例属性 def getlegs (self): #类方法 return self.legs class boy(human): #子类定义 claim='This is boy class.' #类属性 def __init__ (self,legs): #构造器 human.__init__(self,legs) def setname(self,names): #子类方法 self.names = names #实例属性 def setclaim (self,strings): self.claim = strings #实例属性 if __name__ == '__main__': xboy = boy(2) #生成实例 print xboy.legs #打印实例属性 xboy.setname('Jim') #调用实例方法设置实例属性 print xboy.names #打印实例属性 print xboy.claim #打印实例属性，不存在，则继承同名类属性 xboy.setclaim('This is boy instance') #用实例方法设置实例属性 print xboy.claim #打印实例属性 输出结果如下：12345---------- python ----------2JimThis is boy class.This is boy instance 11.python的模块和包模块对应python文件比如import time就是导入的time.py文件。常见导入方式：import ModuleNamefrom ModuleName import Method 实例：&gt;&gt;&gt;import urllib&gt;&gt;&gt;urllib.open(&quot;www.xxx.com&quot;) 如果import的名字太长，可以用import longlonglongname as shortname 模块搜索路径在导入模块时，依次搜索主目录，PYTHONPATH目录，标准库目录, .py文件目录。python模块的导入，只会被载入和执行一次。除非使用reload再次导入。 python的包也可以将一个目录作为包导入。目录里要有init.py文件。它完成包的一些初始化工作。包导入：import dir1.dir2.mod。表示导入目录dir1下的目录dir2下的mod.py。这里dir1和dir2下都要有__init__.py文件。 __name__和__main__：文件如果是以顶层文件执行，则启动时，__name__就被设置为“__main__”;文件如果是被作为模块导入，则被载入时__name__就被设置为模块名称。所以，编写一个文件，常常用到if来判断：12if __name__ == '__main__': run as main. 12.python的命名空间、作用域直接通过代码例子说明如下： #encoding=utf-8 #manynames.py X=11 #模块全局变量X def f(): print X #打印全局变量X def g (): X=22 #函数局部变量X print X class C(): X=33 #类属性C.X def m (self): X=44 #类方法局部变量X self.X=55 #实例属性X if __name__=='__main__': print X #11.全局变量X f() #11.全局变量X g() #22.函数局部变量X print X #11.还是全局变量X obj=C() print obj.X #33.继承类属性X obj.m() print obj.X #55. 实例属性X print C.X #33. 类属性X]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2019%2F02%2F19%2Fjava-basics.html</url>
    <content type="text"><![CDATA[类和对象接口与继承接口对象转型重写多态隐藏superObject类final抽象类内部类默认方法#]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地藏菩萨本愿经]]></title>
    <url>%2F2018%2F12%2F27%2Fdizangjing.html</url>
    <content type="text"><![CDATA[唐●于阗国●三藏沙门●实叉难陀 译 开经偈无上甚深微妙法 百千万劫难遭遇我今见闻得受持 愿解如来真实义 地藏菩萨本愿经卷上忉利天宫神通品第一如是我闻，一时佛在忉利天，为母说法。尔时十方无量世界，不可说不可说，一切诸佛，及大菩萨摩诃萨，皆来集会，赞叹释迦牟尼佛，能于五浊恶世，现不可思议大智慧神通之力，调伏刚强众生，知苦乐法。各遣侍者，问讯世尊。 是时如来含笑，放百千万亿大光明云，所谓大圆满光明云、大慈悲光明云、大智慧光明云、大般若光明云、大三昧光明云、大吉祥光明云、大福德光明云、大功德光明云、大皈依光明云、大赞叹光明云，放如是等不可说光明云已。 又出种种微妙之音，所谓檀波罗蜜音、尸波罗蜜音、羼提波罗蜜音、毗离耶波罗蜜音、禅波罗蜜音、般若波罗蜜音、慈悲音、喜舍音、解脱音、无漏音、智慧音、大智慧音、师子吼音、大师子吼音、云雷音、大云雷音，出如是等不可说不可说音已。 娑婆世界，及他方国土，有无量亿天龙鬼神，亦集到忉利天宫。所谓四天王天、忉利天、须焰摩天、兜率陀天、化乐天、他化自在天、梵众天、梵辅天、大梵天、少光天、无量光天、光音天、少净天、无量净天、遍净天、福生天、福爱天、广果天、无想天、无烦天、无热天、善见天、善现天、色究竟天、摩醯首罗天，乃至非想非非想处天，一切天众、龙众、鬼神等众，悉来集会。 复有他方国土，及娑婆世界，海神、江神、河神、树神、山神、地神、川泽神、苗稼神、昼神、夜神、空神、天神、饮食神、草木神，如是等神，皆来集会。 复有他方国土，及娑婆世界，诸大鬼王，所谓恶目鬼王、啖血鬼王、啖精气鬼王、啖胎卵鬼王、行病鬼王、摄毒鬼王、慈心鬼王、福利鬼王、大爱敬鬼王，如是等鬼王，皆来集会。 尔时释迦牟尼佛，告文殊师利法王子菩萨摩诃萨：汝观是一切诸佛菩萨及天龙鬼神，此世界、他世界，此国土、他国土，如是今来集会到忉利天者，汝知数不？ 文殊师利白佛言：世尊！若以我神力，千劫测度，不能得知。 佛告文殊师利：吾以佛眼观故，犹不尽数，此皆是地藏菩萨久远劫来，已度、当度、未度，已成就、当成就、未成就。 文殊师利白佛言：世尊！我已过去久修善根，证无碍智，闻佛所言，即当信受。小果声闻，天龙八部，及未来世诸众生等，虽闻如来诚实之语，必怀疑惑。设使顶受，未免兴谤。唯愿世尊，广说地藏菩萨摩诃萨，因地作何行？立何愿？而能成就不思议事。 佛告文殊师利：譬如三千大千世界，所有草木丛林，稻麻竹苇，山石微尘，一物一数，作一恒河，一恒河沙，一沙一界，一界之内，一尘一劫，一劫之内，所积尘数，尽充为劫，地藏菩萨证十地果位以来，千倍多于上喻，何况地藏菩萨在声闻辟支佛地。 文殊师利！此菩萨威神誓愿，不可思议。若未来世，有善男子、善女人，闻是菩萨名字，或赞叹，或瞻礼，或称名，或供养，乃至彩画刻镂塑漆形像，是人当得百返生于三十三天，永不堕恶道。 文殊师利！是地藏菩萨摩诃萨，于过去久远不可说不可说劫前，身为大长者子，时世有佛，号曰师子奋迅具足万行如来。时长者子见佛相好，千福庄严，因问彼佛，作何行愿，而得此相？时师子奋迅具足万行如来告长者子：欲证此身，当须久远度脱一切受苦众生。 文殊师利！时长者子，因发愿言：我今尽未来际，不可计劫，为是罪苦六道众生，广设方便，尽令解脱，而我自身方成佛道。以是于彼佛前立斯大愿，于今百千万亿那由他不可说劫，尚为菩萨。 又于过去不可思议阿僧祇劫，时世有佛，号曰觉华定自在王如来，彼佛寿命四百千万亿阿僧祇劫。像法之中，有一婆罗门女，宿福深厚，众所钦敬，行住坐卧，诸天卫护，其母信邪，常轻三宝。是时圣女，广设方便，劝诱其母，令生正见，而此女母，未全生信，不久命终，魂神堕在无间地狱。时婆罗门女，知母在世，不信因果，计当随业，必生恶趣，遂卖家宅，广求香华，及诸供具，于先佛塔寺，大兴供养，见觉华定自在王如来，其形像在一寺中，塑画威容，端严毕备。 时婆罗门女，瞻礼尊容，倍生敬仰，私自念言：佛名大觉，具一切智，若在世时，我母死后，傥来问佛，必知处所。 时婆罗门女，垂泣良久，瞻恋如来，忽闻空中声曰：泣者圣女，勿至悲哀，我今示汝母之去处。 婆罗门女合掌向空，而白空曰：是何神德，宽我忧虑？我自失母以来，昼夜忆恋，无处可问，知母生界。 时空中有声，再报女曰：我是汝所瞻礼者，过去觉华定自在王如来，见汝忆母，倍于常情，众生之分，故来告示。 婆罗门女闻此声已，举身自扑，肢节皆损，左右扶侍，良久方苏，而白空曰：愿佛慈愍，速说我母生界，我今身心将死不久。 时觉华定自在王如来，告圣女曰：汝供养毕，但早返舍，端坐思惟吾之名号，即当知母所生去处。 时婆罗门女寻礼佛已即归其舍，以忆母故，端坐念觉华定自在王如来，经一日一夜，忽见自身到一海边，其水涌沸，多诸恶兽，尽复铁身，飞走海上，东西驰逐；见诸男子女人，百千万数，出没海中，被诸恶兽争取食啖；又见夜叉，其形各异，或多手多眼，多足多头，口牙外出，利刃如剑，驱诸罪人，使近恶兽，复自搏攫，头足相就，其形万类，不敢久视。时婆罗门女，以念佛力故，自然无惧。 有一鬼王，名曰无毒，稽首来迎，白圣女曰：善哉菩萨！何缘来此？ 时婆罗门女问鬼王曰：此是何处？ 无毒答曰：此是大铁围山，西面第一重海。 圣女问曰：我闻铁围之内，地狱在中，是事实不？ 无毒答曰：实有地狱。 圣女问曰：我今云何得到狱所？ 无毒答曰：若非威神，即须业力，非此二事，终不能到。 圣女又问：此水何缘，而乃涌沸，多诸罪人，及以恶兽？ 无毒答曰：此是阎浮提造恶众生，新死之者，经四十九日后，无人继嗣，为作功德，救拔苦难，生时又无善因，当据本业所感地狱，自然先渡此海。海东十万由旬，又有一海，其苦倍此，彼海之东，又有一海，其苦复倍，三业恶因之所招感，共号业海，其处是也。 圣女又问鬼王无毒曰：地狱何在？ 无毒答曰：三海之内，是大地狱，其数百千，各各差别。所谓大者，具有十八，次有五百，苦毒无量，次有千百，亦无量苦。 圣女又问大鬼王曰：我母死来未久，不知魂神当至何趣？ 鬼王问圣女曰：菩萨之母，在生习何行业？ 圣女答曰：我母邪见，讥毁三宝，设或暂信，旋又不敬，死虽日浅，未知生处？ 无毒问曰：菩萨之母，姓氏何等？ 圣女答曰：我父我母，俱婆罗门种，父号尸罗善现，母号悦帝利。 无毒合掌启菩萨曰：愿圣者却返本处，无至忧忆悲恋，悦帝利罪女，生天以来，经今三日，云承孝顺之子，为母设供修福，布施觉华定自在王如来塔寺，非唯菩萨之母，得脱地狱，应是无间罪人，此日悉得受乐，俱同生讫，鬼王言毕，合掌而退。 婆罗门女寻如梦归，悟此事已，便于觉华定自在王如来塔像之前，立弘誓愿：愿我尽未来劫，应有罪苦众生，广设方便，使令解脱。 佛告文殊师利：时鬼王无毒者，当今财首菩萨是；婆罗门女者，即地藏菩萨是。 分身集会品第二尔时，百千万亿不可思、不可议、不可量、不可说无量阿僧祇世界，所有地狱处，分身地藏菩萨，俱来集在忉利天宫。以如来神力故，各以方面，与诸得解脱。从业道出者，亦各有千万亿那由他数，共持香华，来供养佛，彼诸同来等辈，皆因地藏菩萨教化，永不退转于阿耨多罗三藐三菩提。是诸众等，久远劫来，流浪生死，六道受苦，暂无休息，以地藏菩萨广大慈悲，深誓愿故，各获果证，既至忉利，心怀踊跃，瞻仰如来，目不暂舍。 尔时世尊舒金色臂，摩百千万亿不可思、不可议、不可量、不可说无量阿僧祇世界诸分身地藏菩萨摩诃萨顶，而作是言：吾于五浊恶世，教化如是刚强众生，令心调伏，舍邪归正，十有一二，尚恶习在，吾亦分身千百亿，广设方便，或有利根，闻即信受，或有善果，勤劝成就，或有暗钝，久化方归，或有业重，不生敬仰，如是等辈众生，各各差别，分身度脱，或现男子身，或现女人身，或现天龙身，或现神鬼身，或现山林川原，河池泉井，利及于人，悉皆度脱，或现天帝身，或现梵王身，或现转轮王身，或现居士身，或现国王身，或现宰辅身，或现官属身，或现比丘比丘尼，优婆塞优婆夷身，乃至声闻罗汉，辟支佛菩萨等身，而以化度，非但佛身独现其前，汝观吾累劫勤苦度脱如是等，难化刚强罪苦众生，其有未调伏者，随业报应，若堕恶趣，受大苦时汝当忆念吾在忉利天宫慇懃付嘱，令娑婆世界至弥勒出世以来众生，悉使解脱，永离诸苦，遇佛授记。 尔时诸世界，分身地藏菩萨，共复一形，涕泪哀恋，白其佛言，我从久远劫来，蒙佛接引，使获不可思议神力，具大智慧，我所分身，遍满百千万亿恒河沙世界，每一世界化百千万亿身，每一身度百千万亿人，令归敬三宝永离生死，至涅槃乐，但于佛法中所为善事，一毛一渧，一沙一尘，或毫发许，我渐度脱，使获大利，唯愿世尊，不以后世恶业众生为虑，如是三白佛言，唯愿世尊，不以后世恶业众生为虑。 尔时佛赞地藏菩萨言：善哉善哉！吾助汝喜，汝能成就久远劫来，发弘誓愿，广度将毕，即证菩提。 观众生业缘品第三尔时佛母摩耶夫人，恭敬合掌问地藏菩萨言：圣者！阎浮众生，造业差别，所受报应，其事云何？ 地藏答言：千万世界，乃及国土，或有地狱，或无地狱，或有女人，或无女人，或有佛法，或无佛法，乃至声闻辟支佛，亦复如是，非但地狱罪报一等。 摩耶夫人重白菩萨：且愿闻于阎浮罪报所感恶趣。 地藏答言：圣母！唯愿听受，我粗说之。 佛母白言：愿圣者说。 尔时地藏菩萨白圣母言：南阎浮提，罪报名号如是， 若有众生不孝父母，或至杀害，当堕无间地狱，千万亿劫，求出无期。 若有众生出佛身血，毁谤三宝，不敬尊经，亦当堕于无间地狱，千万亿劫，求出无期。 若有众生侵损常住，玷污僧尼，或伽蓝内恣行淫欲，或杀或害，如是等辈，当堕无间地狱，千万亿劫，求出无期。 若有众生伪作沙门，心非沙门，破用常住，欺诳白衣，违背戒律，种种造恶，如是等辈，当堕无间地狱，千万亿劫，求出无期。 若有众生偷窃常住财物谷米，饮食衣服，乃至一物不与取者，当堕无间地狱，千万亿劫，求出无期。 地藏白言：圣母！若有众生作如是罪，当堕五无间地狱，求暂停苦一念不得。 摩耶夫人重白地藏菩萨言：云何名为无间地狱？ 地藏白言：圣母！诸有地狱在大铁围山之内，其大地狱有一十八所，次有五百，名号各别，次有千百，名字亦别，无间狱者，其狱城周匝八万余里，其城纯铁，高一万里，城上火聚，少有空缺，其狱城中，诸狱相连，名号各别，独有一狱，名曰无间，其狱周匝万八千里，狱墙高一千里，悉是铁围，上火彻下，下火彻上，铁蛇铁狗，吐火驰逐狱墙之上，东西而走，狱中有床，遍满万里，一人受罪，自见其身遍卧满床，千万人受罪，亦各自见身满床上，众业所感获报如是。 又诸罪人，备受众苦，千百夜叉及以恶鬼，口牙如剑，眼如电光，手复铜爪，拖拽罪人，复有夜叉执大铁戟，中罪人身，或中口鼻，或中腹背，抛空翻接，或置床上；复有铁鹰啖罪人目；复有铁蛇绞罪人颈，百肢节内，悉下长钉，拔舌耕犁，抽肠锉斩，烊铜灌口，热铁缠身，万死千生，业感如是，动经亿劫，求出无期，此界坏时，寄生他界，他界次坏，转寄他方，他方坏时，辗转相寄，此界成后，还复而来，无间罪报，其事如是。 又五事业感，故称无间，何等为五？ 一者，日夜受罪，以至劫数，无时间绝，故称无间。 二者，一人亦满，多人亦满，故称无间。 三者，罪器叉棒，鹰蛇狼犬，碓磨锯凿，锉斫镬汤，铁网铁绳，铁驴铁马，生革络首，热铁浇身，饥吞铁丸，渴饮铁汁，从年竟劫，数那由他，苦楚相连，更无间断，故称无间。 四者，不问男子女人，羌胡夷狄，老幼贵贱，或龙或神，或天或鬼，罪行业感，悉同受之，故称无间。 五者，若堕此狱，从初入时，至百千劫，一日一夜，万死万生，求一念间暂住不得，除非业尽，方得受生，以此连绵，故称无间。 地藏菩萨白圣母言：无间地狱，粗说如是，若广说地狱罪器等名，及诸苦事，一劫之中，求说不尽，摩耶夫人闻已，愁忧合掌，顶礼而退。 阎浮众生业感品第四尔时地藏菩萨摩诃萨白佛言：世尊！我承佛如来威神力故，遍百千万亿世界，分是身形，救拔一切业报众生，若非如来大慈力故，即不能作如是变化，我今又蒙佛付嘱，至阿逸多成佛已来，六道众生，遣令度脱，唯然世尊，愿不有虑。 尔时佛告地藏菩萨，一切众生未解脱者，性识无定，恶习结业，善习结果，为善为恶，逐境而生，轮转五道，暂无休息，动经尘劫，迷惑障难，如鱼游网，将是长流，脱入暂出，又复遭网，以是等辈，吾当忧念，汝既毕是往愿，累劫重誓，广度罪辈，吾复何虑。 说是语时，会中有一菩萨摩诃萨，名定自在王，白佛言：世尊！地藏菩萨累劫以来，各发何愿？今蒙世尊慇懃赞叹，唯愿世尊，略而说之。 尔时世尊告定自在王菩萨：谛听谛听！善思念之！吾当为汝分别解说。乃往过去无量阿僧祇那由他不可说劫，尔时有佛，号一切智成就如来、应供、正遍知、明行足、善逝、世间解、无上士、调御丈夫、天人师、佛、世尊，其佛寿命六万劫，未出家时，为小国王，与一邻国王为友，同行十善，饶益众生，其邻国内所有人民，多造众恶，二王议计，广设方便。一王发愿：早成佛道，当度是辈，令使无余。一王发愿：若不先度罪苦，令是安乐，得至菩提，我终未愿成佛。 佛告定自在王菩萨，一王发愿早成佛者，即一切智成就如来是；一王发愿永度罪苦众生，未愿成佛者，即地藏菩萨是。 复于过去无量阿僧祇劫，有佛出世，名清净莲华目如来，其佛寿命四十劫，像法之中，有一罗汉，福度众生，因次教化，遇一女人，字曰光目，设食供养。 罗汉问之，欲愿何等？ 光目答言，我以母亡之日，资福救拔，未知我母生处何趣？ 罗汉愍之，为入定观，见光目女母堕在恶趣，受极大苦。罗汉问光目言：汝母在生作何行业，今在恶趣受极大苦？ 光目答言：我母所习，唯好食啖鱼鳖之属，所食鱼鳖，多食其子，或炒或煮，恣情食啖，计其命数，千万复倍，尊者慈愍，如何哀救？ 罗汉愍之，为作方便，劝光目言：汝可志诚念清净莲华目如来，兼塑画形像，存亡获报。 光目闻已，即舍所爱，寻画佛像而供养之，复恭敬心，悲泣瞻礼，忽于夜后，梦见佛身金色晃耀，如须弥山，放大光明，而告光目：汝母不久当生汝家，才觉饥寒。即当言说，其后家内婢生一子，未满三日，而乃言说，稽首悲泣，告于光目：生死业缘，果报自受，吾是汝母，久处暗冥，自别汝来，累堕大地狱，蒙汝福力，方得受生，为下贱人，又复短命，寿年十三，更落恶道，汝有何计，令吾脱免？ 光目闻说，知母无疑，哽咽悲啼，而白婢子：既是我母，合知本罪，作何行业，堕于恶道？ 婢子答言：以杀害毁骂二业受报，若非蒙福，救拔吾难，以是业故，未合解脱。 光目问言：地狱罪报，其事云何？ 婢子答言：罪苦之事，不忍称说，百千岁中，卒白难竟。 光目闻已，啼泪号泣而白空界：愿我之母，永脱地狱，毕十三岁，更无重罪，及历恶道，十方诸佛慈哀愍我，听我为母所发广大誓愿，若得我母永离三途及斯下贱，乃至女人之身永劫不受者，愿我自今日后，对清净莲华目如来像前，却后百千万亿劫中，应有世界，所有地狱及 三恶道诸罪苦众生，誓愿救拔，令离地狱恶趣，畜生饿鬼等，如是罪报等人，尽成佛竟，我然后方成正觉。 发誓愿已，具闻清净莲华目如来而告之曰：光目，汝大慈愍，善能为母发如是大愿，吾观汝母十三岁毕，舍此报已，生为梵志，寿年百岁，过是报后，当生无忧国土，寿命不可计劫，后成佛果，广度人天，数如恒河沙。 佛告定自在王：尔时罗汉福度光目者，即无尽意菩萨是；光目母者，即解脱菩萨是；光目女者，即地藏菩萨是。过去久远劫中，如是慈愍，发恒河沙愿，广度众生，未来世中，若有男子女人，不行善者行恶者，乃至不信因果者，邪淫妄语者，两舌恶口者，毁谤大乘者，如是诸业众生，必堕恶趣。若遇善知识，劝令一弹指间，归依地藏菩萨，是诸众生，即得解脱三恶道报。若能志心归敬及瞻礼赞叹，香华衣服，种种珍宝，或复饮食，如是奉事者，未来百千万亿劫中，常在诸天受胜妙乐，若天福尽，下生人间，犹百千劫常为帝王，能忆宿命因果本末。 定自在王！如是地藏菩萨，有如此不可思议大威神力，广利众生，汝等诸菩萨当记是经，广宣流布，定自在王白佛言，世尊，愿不有虑，我等千万亿菩萨摩诃萨，必能承佛威神，广演是经，于阎浮提利益众生。 定自在王菩萨白世尊已，合掌恭敬作礼而退。 尔时四方天王俱从座起，合掌恭敬白佛言：世尊！地藏菩萨于久远劫来，发如是大愿，云何至今犹度未绝，更发广大誓言？唯愿世尊为我等说。 佛告四天王：善哉善哉！吾今为汝及未来现在天人众等，广利益故，说地藏菩萨，于娑婆世界，阎浮提内，生死道中，慈哀救拔度脱一切罪苦众生方便之事。 四天王言：唯然，世尊！愿乐欲闻。 佛告四天王：地藏菩萨久远劫来，迄至于今，度脱众生，犹未毕愿，慈愍此世罪苦众生，复观未来无量劫中，因蔓不断，以是之故，又发重愿，如是菩萨于娑婆世界，阎浮提中，百千万亿方便，而为教化。 四天王！地藏菩萨，若遇杀生者，说宿殃短命报；若遇窃盗者，说贫穷苦楚报；若遇邪淫者，说雀鸽鸳鸯报；若遇恶口者，说眷属斗诤报；若遇毁谤者，说无舌疮口报；若遇嗔恚者，说丑陋癃残报；若遇悭吝者，说所求违愿报；若遇饮食无度者，说饥渴咽病报；若遇畋猎恣情者，说惊狂丧命报；若遇悖逆父母者，说天地灾杀报；若遇烧山林木者，说狂迷取死报；若遇前后父母恶毒者，说返生鞭挞现受报；若遇网捕生雏者，说骨肉分离报；若遇毁谤三宝者，说盲聋喑哑报；若遇轻法慢教者，说永处恶道报；若遇破用常住者，说亿劫轮回地狱报；若遇污梵诬僧者，说永在畜生报；若遇汤火斩斫伤生者，说轮回递偿报；若遇破戒犯斋者，说禽兽饥饿报；若遇非理毁用者，说所求阙绝报；若遇吾我贡高者，说卑使下贱报；若遇两舌斗乱者，说无舌百舌报；若遇邪见者，说边地受生报。 如是等阎浮提众生，身口意业，恶习结果，百千报应，今粗略说。如是等阎浮提众生业感差别，地藏菩萨百千方便而教化之。是诸众生，先受如是等报，后堕地狱，动经劫数，无有出期。是故汝等护人护国，无令是诸众业，迷惑众生，四天王闻已，涕泪悲叹合掌而退。 地藏菩萨本愿经卷中地狱名号品第五尔时普贤菩萨摩诃萨白地藏菩萨言：仁者，愿为天龙四众，及未来现在一切众生，说娑婆世界，及阎浮提罪苦众生，所受报处，地狱名号，及恶报等事，使未来世末法众生，知是果报。 地藏答言：仁者，我今承佛威神，及大士之力，略说地狱名号，及罪报恶报之事。仁者，阎浮提东方有山，号曰铁围，其山黑邃，无日月光，有大地狱，号极无间。又有地狱，名大阿鼻；复有地狱，名曰四角；复有地狱，名曰飞刀；复有地狱，名曰火箭；复有地狱，名曰夹山；复有地狱，名曰通枪；复有地狱，名曰铁车；复有地狱，名曰铁床；复有地狱，名曰铁牛；复有地狱，名曰铁衣；复有地狱，名曰千刃；复有地狱，名曰铁驴；复有地狱，名曰烊铜；复有地狱，名曰抱柱；复有地狱，名曰流火；复有地狱；名曰耕舌；复有地狱，名曰锉首；复有地狱，名曰烧脚；复有地狱，名曰啖眼；复有地狱，名曰铁丸；复有地狱，名曰诤论；复有地狱，名曰铁鈇；复有地狱，名曰多嗔。 地藏白言：仁者，铁围之内，有如是等地狱，其数无限，更有叫唤地狱、拔舌地狱、粪尿地狱、铜锁地狱、火象地狱、火狗地狱、火马地狱、 火牛地狱、火山地狱、火石地狱、火床地狱、火梁地狱、火鹰地狱、锯牙地狱、 剥皮地狱、饮血地狱、烧手地狱、烧脚地狱、倒刺地狱、火屋地狱、铁屋地狱、 火狼地狱，如是等地狱，其中各各复有诸小地狱，或一，或二，或三，或四，乃至百千，其中名号，各各不同。 地藏菩萨告普贤菩萨言：仁者，此者皆是南阎浮提行恶众生，业感如是，业力甚大，能敌须弥，能深巨海，能障圣道。是故众生，莫轻小恶，以为无罪，死后有报，纤毫受之，父子至亲，歧路各别，纵然相逢，无肯代受。我今承佛威力，略说地狱罪报之事，唯愿仁者暂听是言。 普贤答言：吾已久知三恶道报，望仁者说，令后世末法一切恶行众生，闻仁者说，使令归佛。 地藏白言：仁者，地狱罪报，其事如是， 或有地狱，取罪人舌，使牛耕之；或有地狱，取罪人心，夜叉食之；或有地狱，镬汤盛沸，煮罪人身；或有地狱，赤烧铜柱，使罪人抱；或有地狱，使诸火烧，趁及罪人；或有地狱，一向寒冰；或有地狱，无限粪尿；或有地狱，纯飞钑鑗；或有地狱，多攒火枪；或有地狱，唯撞胸背；或有地狱，但烧手足；或有地狱，盘绞铁蛇；或有地狱，驱逐铁狗；或有地狱，尽驾铁骡。 仁者，如是等报，各各狱中，有百千种业道之器，无非是铜是铁，是石是火，此四种物，众业行感，若广说地狱罪报等事，一一狱中，更有百千种苦楚，何况多狱，我今承佛威神及仁者问，略说如是，若广解说，穷劫不尽。 如来赞叹品第六尔时世尊举身放大光明，遍照百千万亿恒河沙等诸佛世界，出大音声，普告诸佛世界一切诸菩萨摩诃萨，及天龙鬼神人非人等，听吾今日称扬赞叹地藏菩萨摩诃萨，于十方世界，现大不可思议威神慈悲之力，救护一切罪苦之事；吾灭度后，汝等诸菩萨大士，及天龙鬼神等，广作方便，卫护是经，令一切众生证涅槃乐。 说是语已，会中有一菩萨，名曰普广，合掌恭敬而白佛言：今见世尊赞叹地藏菩萨，有如是不可思议大威神德，唯愿世尊为未来世末法众生，宣说地藏菩萨利益人天因果等事，使诸天龙八部，及未来世众生，顶受佛语。 尔时世尊告普广菩萨及四众等：谛听谛听，吾当为汝略说地藏菩萨利益人天福德之事。普广白言：唯然世尊，愿乐欲闻。 佛告普广菩萨：未来世中，若有善男子善女人，闻是地藏菩萨摩诃萨名者，或合掌者，赞叹者，作礼者，恋慕者，是人超越三十劫罪。 普广！若有善男子善女人，或彩画形像，或土石胶漆，金银铜铁，作此菩萨，一瞻一礼者，是人百返生于三十三天，永不堕于恶道。假如天福尽故，下生人间，犹为国王，不失大利。 若有女人，厌女人身，尽心供养地藏菩萨画像，及土石胶漆铜铁等像，如是日日不退，常以华香、饮食、衣服、缯彩、幢幡、钱宝物等供养，是善女人，尽此一报女身，百千万劫，更不生有女人世界，何况复受，除非慈愿力故，要受女身，度脱众生，承斯供养地藏力故，及功德力，百千万劫不受女身。 复次普广！若有女人，厌是丑陋，多疾病者，但于地藏像前，志心瞻礼，食顷之间，是人千万劫中，所受生身，相貌圆满，是丑陋女人，如不厌女身，即百千万亿生中，常为王女，乃及王妃，宰辅大姓，大长者女，端正受生，诸相圆满，由志心故，瞻礼地藏菩萨，获福如是。 复次普广！若有善男子善女人，能对菩萨像前，作诸伎乐，及歌咏赞叹，香华供养，乃至劝于一人多人，如是等辈，现在世中及未来世，常得百千鬼神日夜卫护，不令恶事辄闻其耳，何况亲受诸横。 复次普广！未来世中，若有恶人及恶神恶鬼，见有善男子、善女人，归敬供养赞叹瞻礼地藏菩萨形像，或妄生讥毁，谤无功德及利益事，或露齿笑，或背面非，或劝人共非，或一人非，或多人非，乃至一念生讥毁者，如是之人，贤劫千佛灭度，讥毁之报，尚在阿鼻地狱受极重罪。过是劫已，方受饿鬼，又经千劫，复受畜生。又经千劫，方得人身，纵受人身，贫穷下贱，诸根不具，多被恶业来结其心。不久之间，复堕恶道。是故普广！讥毁他人供养，尚获此报，何况别生恶见毁灭。 复次普广！若未来世，有男子、女人，久处床枕，求生求死，了不可得，或夜梦恶鬼，乃及家亲，或游险道，或多魇寐，共鬼神游，日月岁深，转复尪穄，眠中叫苦，惨凄不乐者，此皆是业道论对，未定轻重，或难舍寿，或不得愈，男女俗眼，不辨是事，但当对诸菩萨像前，高声转读此经一遍，或取病人可爱之物，或衣服宝贝，庄园舍宅，对病人前，高声唱言：我某甲等，为是病人，对经像前舍诸等物，或供养经像，或造佛菩萨形像，或造塔寺，或燃油灯，或施常住。如是三白病人，遣令闻知，假令诸识分散，至气尽者，乃至一日、二日、三日、四日，至七日已来，但高声白，高声读经，是人命终之后，宿殃重罪，至于五无间罪，永得解脱，所受生处，常知宿命，何况善男子、善女人自书此经，或教人书，或自塑画菩萨形像，乃至教人塑画，所受果报，必获大利。 是故普广！若见有人读诵是经，乃至一念赞叹是经，或恭敬者，汝须百千方便，劝是等人，勤心莫退，能得未来现在千万亿不可思议功德。 复次普广！若未来世诸众生等，或梦或寐，见诸鬼神乃及诸形，或悲或啼，或愁或叹，或恐或怖，此皆是一生十生百生千生过去父母男女弟妹，夫妻眷属，在于恶趣，未得出离，无处希望福力救拔，当告宿世骨肉，使作方便，愿离恶道。 普广！汝以神力，遣是眷属，令对诸佛菩萨像前，志心自读此经，或请人读，其数三遍或七遍，如是恶道眷属，经声毕是遍数，当得解脱，乃至梦寐之中，永不复见。 复次普广！若未来世，有诸下贱等人，或奴或婢，乃至诸不自由之人，觉知宿业，要忏悔者，志心瞻礼地藏菩萨形像，乃至一七日中，念菩萨名，可满万遍，如是等人，尽此报后，千万生中，常生尊贵，更不经三恶道苦。 复次普广！若未来世中，阎浮提内，刹利、婆罗门、长者、居士，一切人等，及异姓种族，有新产者，或男或女，七日之中，早与读诵此不思议经典，更为念菩萨名，可满万遍．是新生子，或男或女，宿有殃报，便得解脱，安乐易养，寿命增长，若是承福生者，转增安乐，及与寿命。 复次普广！若未来世众生，于月一日、八日、十四日、十五日、十八日、二十三、二十四、二十八、二十九日，乃至三十日，是诸日等，诸罪结集，定其轻重，南阎浮提众生，举止动念，无不是业，无不是罪，何况恣情杀害、窃盗、邪淫、妄语，百千罪状，能于是十斋日，对佛菩萨诸贤圣像前，读是经一遍，东西南北百由旬内，无诸灾难；当此居家若长若幼，现在未来百千岁中，永离恶趣。能于十斋日每转一遍，现世令此居家，无诸横病衣食丰溢。 是故普广！当知地藏菩萨，有如是等不可说百千万亿大威神力，利益之事，阎浮众生，于此大士有大因缘，是诸众生，闻菩萨名，见菩萨像，乃至闻是经三字五字，或一偈一句者，现在殊妙安乐，未来之世，百千万生，常得端正，生尊贵家。 尔时普广菩萨！闻佛如来称扬赞叹地藏菩萨已，胡跪合掌，复白佛言：世尊，我久知是大士有如此不可思议神力，及大誓愿力，为未来众生遣知利益，故问如来，唯然顶受。 世尊！当何名此经，使我云何流布？ 佛告普广：此经有三名，一名地藏本愿，亦名地藏本行，亦名地藏本誓力经。缘此菩萨，久远劫来，发大重愿，利益众生。是故汝等，依愿流布，普广闻已，合掌恭敬作礼而退。 利益存亡品第七尔时地藏菩萨摩诃萨白佛言：世尊！我观是阎浮提众生，举心动念，无非是罪，脱获善利，多退初心，若遇恶缘，念念增益，是等辈人，如履泥涂，负于重石，渐困渐重，足步深邃，若得遇知识，替与减负，或全与负，是知识有大力故，复相扶助，劝令牢脚，若达平地，须省恶路，无再经历。 世尊！习恶众生，从纤毫间，便至无量，是诸众生有如此习，临命终时，父母眷属，宜为设福，以资前路，或悬幡盖及然油灯，或转读尊经，或供养佛像及诸圣像，乃至念佛菩萨，及辟支佛名字，一名一号，历临终人耳根，或闻在本识，是诸众生所造恶业，计其感果，必堕恶趣，缘是眷属为临终人修此圣因，如是众罪，悉皆消灭。若能更为身死之后，七七日内，广造众善，能使是诸众生 永离恶趣，得生人天，受胜妙乐，现在眷属，利益无量。是故我今对佛世尊，及天龙八部，人非人等，劝于阎浮提众生，临终之日，慎勿杀害，及造恶缘，拜祭鬼神，求诸魍魉。何以故？尔所杀害乃至拜祭，无纤毫之力，利益亡人，但结罪缘，转增深重，假使来世或现在生，得获圣分，生人天中，缘是临终被诸眷属造是恶因，亦令是命终人殃累对辩，晚生善处，何况临命终人，在生未曾有少善根，各据本业，自受恶趣，何忍眷属，更为增业，譬如有人从远地来，绝粮三日，所负担物，强过百斤，忽遇邻人，更附少物，以是之故，转复困重。 世尊！我观阎浮提众生，但能于诸佛教中，乃至善事，一毛一渧，一沙一尘，如是利益，悉皆自得。 说是语时，会中有一长者，名曰大辩，是长者久证无生，化度十方，现长者身，合掌恭敬，问地藏菩萨言：大士！是南阎浮提众生，命终之后，小大眷属，为修功德，乃至设斋，造众善因，是命终人，得大利益及解脱不？ 地藏答言：长者！我今为未来现在一切众生，承佛威力，略说是事。长者！未来现在诸众生等，临命终日，得闻一佛名，一菩萨名，一辟支佛名，不问有罪无罪，悉得解脱，若有男子女人，在生不修善因，多造众罪，命终之后，眷属小大，为造福利一切圣事，七分之中而乃获一，六分功德，生者自利。以是之故，未来现在善男女等，闻健自修，分分己获，无常大鬼，不期而到，冥冥游神，未知罪福，七七日内，如痴如聋，或在诸司，辩论业果，审定之后，据业受生，未测之间，千万愁苦，何况堕于诸恶趣等。是命终人，未得受生，在七七日内，念念之间，望诸骨肉眷属，与造福力救拔，过是日后，随业受报。若是罪人，动经千百岁中，无解脱日。若是五无间罪，堕大地狱，千劫万劫，永受众苦。 复次长者！如是罪业众生，命终之后，眷属骨肉，为修营斋，资助业道，未斋食竟，及营斋之次，米泔菜叶，不弃于地，乃至诸食未献佛僧，勿得先食，如有违食及不精勤，是命终人，了不得力，如精勤护净奉献佛僧，是命终人，七分获一，是故长者，阎浮众生，若能为其父母乃至眷属，命终之后，设斋供养，志心勤恳，如是之人，存亡获利，说是语时，忉利天宫，有千万亿那由他阎浮鬼神，悉发无量菩提之心，大辩长者作礼而退。 阎罗王众赞叹品第八尔时铁围山内，有无量鬼王，与阎罗天子，俱诣忉利，来到佛所，所谓恶毒鬼王、多恶鬼王、大诤鬼王、白虎鬼王、血虎鬼王、赤虎鬼王、散殃鬼王、飞身鬼王、电光鬼王、狼牙鬼王、千眼鬼王、啖兽鬼王、负石鬼王、主耗鬼王、主祸鬼王、主食鬼王、主财鬼王、主畜鬼王、主禽鬼王、主兽鬼王、主魅鬼王、主产鬼王、主命鬼王、主疾鬼王、主险鬼王、三目鬼王、四目鬼王、五目鬼王、祁利失王、大祁利失王、祁利叉王、大祁利叉王、阿那吒王、大阿那吒王，如是等大鬼王，各各与百千诸小鬼王，尽居阎浮提，各有所执，各有所主，是诸鬼王与阎罗天子，承佛威神，及地藏菩萨摩诃萨力，俱诣忉利，在一面立。 尔时，阎罗天子胡跪合掌白佛言：世尊！我等今者与诸鬼王，承佛威神，及地藏菩萨摩诃萨力，方得诣此忉利大会，亦是我等获善利故，我今有小疑事，敢问世尊，唯愿世尊慈悲宣说。 佛告阎罗天子：恣汝所问，吾为汝说。 是时阎罗天子瞻礼世尊，及回视地藏菩萨，而白佛言：世尊！我观地藏菩萨在六道中，百千方便而度罪苦众生，不辞疲倦，是大菩萨有如是不可思议神通之事，然诸众生获 脱罪报，未久之间，又堕恶道。 世尊！是地藏菩萨既有如是不可思议神力，云何众生而不依止善道，永取解脱，唯愿世尊为我解说？ 佛告阎罗天子：南阎浮提众生，其性刚强，难调难伏，是大菩萨，于百千劫，头头救拔如是众生，早令解脱，是罪报人乃至堕大恶趣，菩萨以方便力，拔出根本业缘，而遣悟宿世之事，自是阎浮众生结恶习重，旋出旋入，劳斯菩萨久经劫数而作度脱。譬如有人迷失本家，误入险道，其险道中，多诸夜叉，及虎狼师子，蚖蛇蝮蝎，如是迷人，在险道中，须臾之间，即遭诸毒。有一知识，多解大术，善禁是毒，乃及夜叉诸恶毒等，忽逢迷人欲进险道，而语之言：咄哉男子，为何事故而入此路？有何异术，能制诸毒？是迷路人忽闻是语，方知险道，即便退步，求出此路。是善知识，提携接手，引出险道，免诸恶毒，至于好道，令得安乐，而语之言：咄哉迷人，自今已后，勿履是道。此路入者，卒难得出，复损性命，是迷路人亦生感重。临别之时，知识又言：若见亲知及诸路人，若男若女，言于此路多诸毒恶，丧失性命，无令是众自取其死。 是故地藏菩萨具大慈悲，救拔罪苦众生，生人天中，令受妙乐，是诸罪众，知业道苦，脱得出离，永不再历，如迷路人，误入险道，遇善知识引接令出，永不复入，逢见他人，复劝莫入，自言因是迷故，得解脱竟，更不复入，若再履践，犹尚迷误，不觉旧曾所落险道，或致失命，如堕恶趣，地藏菩萨方便力故，使令解脱，生人天中，旋又再入，若业结重，永处地狱，无解脱时， 尔时，恶毒鬼王合掌恭敬白佛言：世尊！我等诸鬼王，其数无量，在阎浮提，或利益人，或损害人，各各不同，然是业报，使我眷属游行世界，多恶少善，过人家庭，或城邑聚落，庄园房舍，或有男子女人，修毛发善事，乃至悬一幡一盖，少香少华，供养佛像及菩萨像，或转读尊经，烧香供养一句一偈，我等鬼王敬礼是人，如过去现在未来诸佛，敕诸小鬼，各有大力，及土地分，便令卫护，不令恶事横事，恶病横病，乃至不如意事，近于此舍等处，何况入门？佛赞鬼王，善哉善哉！汝等及与阎罗，能如是拥护善男女等，吾亦告梵王帝释，令卫护汝。 说是语时，会中有一鬼王，名曰主命，白佛言：世尊！我本业缘，主阎浮人命，生时死时，我皆主之，在我本愿，甚欲利益，自是众生不会我意，致令生死俱不得安。何以故？是阎浮提人初生之时，不问男女，或欲生时，但作善事，增益舍宅，自令土地无量欢喜，拥护子母，得大安乐，利益眷属，或已生下，慎勿杀害，取诸鲜味，供给产母，及广聚眷属，饮酒食肉，歌乐弦管，能令子母不得安乐。何以故？是产难时，有无数恶鬼及魍魉精魅，欲食腥血，是我早令舍宅土地灵祇，荷护子母，使令安乐，而得利益，如是之人，见安乐故，便合设福，答诸土地，翻为杀害， 集聚眷属，以是之故，犯殃自受，子母俱损。 又阎浮提临命终人，不问善恶，我欲令是命终之人，不堕恶道，何况自修善根增我力故，是阎浮提行善之人，临命终时，亦有百千恶道鬼神，或变作父母，乃至诸眷属，引接亡人，令落恶道，何况本造恶者。 世尊！如是阎浮提男子女人临命终时，神识惛昧，不辩善恶，乃至眼耳更无见闻，是诸眷属，当须设大供养，转读尊经，念佛菩萨名号，如是善缘，能令亡者离诸恶道，诸魔鬼神，悉皆退散。 世尊！一切众生临命终时，若得闻一佛名，一菩萨名，或大乘经典，一句一偈，我观如是辈人，除五无间杀害之罪，小小恶业，合堕恶趣者，寻即解脱。 佛告主命鬼王：汝大慈故，能发如是大愿，于生死中，护诸众生，若未来世中，有男子女人至生死时，汝莫退是愿，总令解脱，永得安乐， 鬼王白佛言：愿不有虑，我毕是形，念念拥护阎浮众生，生时死时，俱得安乐，但愿诸众生于生死时，信受我语，无不解脱，获大利益。 尔时，佛告地藏菩萨：是大鬼王主命者，已曾经百千生，作大鬼王，于生死中，拥护众生，是大士慈悲愿故，现大鬼身，实非鬼也，却后过一百七十劫，当得成佛，号曰无相如来，劫名安乐，世界名净住，其佛寿命不可计劫。地藏！是大鬼王，其事如是不可思议，所度人天亦不可限量。 称佛名号品第九尔时地藏菩萨摩诃萨白佛言：世尊！我今为未来众生演利益事，于生死中，得大利益，唯愿世尊听我说之。 佛告地藏菩萨：汝今欲兴慈悲，救拔一切罪苦六道众生，演不思议事，今正是时，唯当速说，吾即涅槃，使汝早毕是愿，吾亦无忧现在未来一切众生。 地藏菩萨白佛言：世尊！过去无量阿僧祇劫，有佛出世，号无边身如来，若有男子女人闻是佛名，暂生恭敬，即得超越四十劫生死重罪，何况塑画形像，供养赞叹，其人获福无量无边。 又于过去恒河沙劫，有佛出世，号宝性如来，若有男子女人闻是佛名，一弹指顷，发心归依，是人于无上道永不退转。 又于过去有佛出世，号波头摩胜如来，若有男子女人闻是佛名，历于耳根，是人当得千返生于六欲天中，何况至心称念。 又于过去不可说不可说阿僧祇劫，有佛出世，号师子吼如来，若有男子女人闻是佛名，一念归依，是人得遇无量诸佛摩顶授记。 又于过去有佛出世，号拘留孙佛，若有男子女人闻是佛名，志心瞻礼，或复赞叹，是人于贤劫千佛会中，为大梵王，得授上记。 又于过去有佛出世，号毗婆尸佛，若有男子女人闻是佛名，永不堕恶道，常生人天，受胜妙乐。 又于过去无量无数恒河沙劫，有佛出世，号宝胜如来，若有男子女人闻是佛名，毕竟不堕恶道，常在天上受胜妙乐。 又于过去有佛出世，号宝相如来，若有男子女人闻是佛名，生恭敬心，是人不久得阿罗汉果。 又于过去无量阿僧祇劫，有佛出世，号袈裟幢如来，若有男子女人闻是佛名者，超一百大劫生死之罪。 又于过去有佛出世，号大通山王如来，若有男子女人闻是佛名者，是人得遇恒河沙佛广为说法，必成菩提。 又于过去，有净月佛、山王佛、智胜佛、净名王佛、智成就佛、无上佛、妙声佛、满月佛、月面佛，有如是等不可说佛。 世尊！现在未来一切众生，若天若人，若男若女，但念得一佛名号，功德无量，何况多名，是众生等，生时死时，自得大利，终不堕恶道，若有临命终人，家中眷属，乃至一人，为是病人高声念一佛名，是命终人，除五无间罪，余业报等悉得消灭。是五无间罪，虽至极重，动经亿劫，了不得出。承斯临命终时，他人为其称念佛名，于是罪中，亦渐消灭，何况众生自称自念，获福无量，灭无量罪。 地藏菩萨本愿经卷下校量布施功德缘品第十尔时，地藏菩萨摩诃萨承佛威神，从座而起，胡跪合掌白佛言：世尊！我观业道众生，校量布施，有轻有重，有一生受福，有十生受福，有百生千生受大福利者，是事云何？唯愿世尊为我说之。 尔时，佛告地藏菩萨：吾今于忉利天宫一切众会，说阎浮提布施校量功德轻重，汝当谛听，吾为汝说。 地藏白佛言：我疑是事，愿乐欲闻。 佛告地藏菩萨：南阎浮提，有诸国王、宰辅大臣、大长者、大刹利、大婆罗门等，若遇最下贫穷，乃至癃残喑哑，聋痴无目，如是种种不完具者，是大国王等欲布施时，若能具大慈悲下心含笑，亲手遍布施，或使人施，软言慰谕，是国王等所获福利，如布施百恒河沙佛功德之利。何以故？缘是国王等于是最贫贱辈及不完具者，发大慈心，是故福利有如此报，百千生中，常得七宝具足，何况衣食受用。 复次地藏！若未来世，有诸国王，至婆罗门等，遇佛塔寺，或佛形像，乃至菩萨声闻辟支佛像，躬自营办供养布施，是国王等，当得三劫为帝释身，受胜妙乐，若能以此布施福利，回向法界，是大国王等，于十劫中，常为大梵天王。 复次地藏！若未来世，有诸国王，至婆罗门等，遇先佛塔庙，或至经像，毁坏破落，乃能发心修补，是国王等，或自营办，或劝他人，乃至百千人等布施结缘，是国王等，百千生中常为转轮王身，如是他人同布施者，百千生中常为小国王身，更能于塔庙前，发回向心，如是国王乃及诸人，尽成佛道，以此果报无量无边。 复次地藏！未来世中，有诸国王及婆罗门等，见诸老病及生产妇女，若一念间，具大慈心，布施医药饮食卧具，使令安乐，如是福利最不思议，一百劫中常为净居天主，二百劫中常为六欲天主，毕竟成佛，永不堕恶道，乃至百千生中，耳不闻苦声。 复次地藏！若未来世中，有诸国王及婆罗门等，能作如是布施，获福无量，更能回向，不问多少，毕竟成佛，何况释梵转轮之报。 是故地藏，普劝众生当如是学。 复次地藏！未来世中，若善男子、善女人，于佛法中，种少善根，毛发沙尘等许，所受福利，不可为喻。 复次地藏！未来世中，若有善男子、善女人，遇佛形像，菩萨形像，辟支佛形像，转轮王形像，布施供养，得无量福，常在人天受胜妙乐，若能回向法界，是人福利不可为喻。 复次地藏！未来世中，若有善男子。善女人，遇大乘经典，或听闻一偈一句，发殷重心，赞叹恭敬，布施供养，是人获大果报，无量无边，若能回向法界，其福不可为喻。 复次地藏！若未来世中，有善男子、善女人，遇佛塔寺，大乘经典，新者布施供养，瞻礼赞叹，恭敬合掌，若遇故者，或毁坏者，修补营理，或独发心，或劝多人同共发心，如是等辈，三十生中常为诸小国王，檀越之人，常为轮王，还以善法教化诸小国王。 复次地藏！未来世中，若有善男子、善女人，于佛法中所种善根，或布施供养，或修补塔寺，或装理经典，乃至一毛一尘，一沙一渧，如是善事，但能回向法界，是人功德，百千生中受上妙乐，如但回向自家眷属，或自身利益，如是之果，即三生受乐，舍一得万报。是故地藏，布施因缘，其事如是。 地神护法品第十一尔时，坚牢地神白佛言：世尊！我从昔来，瞻视顶礼无量菩萨摩诃萨，皆是大不可思议神通智慧，广度众生，是地藏菩萨摩诃萨，于诸菩萨誓愿深重。 世尊！是地藏菩萨，于阎浮提有大因缘，如文殊普贤，观音弥勒，亦化百千身形，度于六道，其愿尚有毕竟，是地藏菩萨教化六道一切众生，所发誓愿劫数，如千百亿恒河沙。 世尊！我观未来及现在众生，于所住处，于南方清洁之地，以土石竹木作其龛室，是中能塑画，乃至金银铜铁，作地藏形像，烧香供养，瞻礼赞叹，是人居处，即得十种利益。何等为十： 一者，土地丰壤；二者，家宅永安；三者，先亡生天；四者，现存益寿； 五者，所求遂意；六者，无水火灾；七者，虚耗辟除；八者，杜绝恶梦；九者，出入神护；十者，多遇圣因。 世尊！未来世中，及现在众生，若能于所住处方面，作如是供养，得如是利益。 复白佛言：世尊！未来世中，若有善男子、善女人，于所住处，有此经典及菩萨像，是人更能转读经典，供养菩萨，我常日夜以本神力，卫护是人，乃至水火盗贼，大横小横，一切恶事，悉皆消灭。 佛告坚牢地神：汝大神力，诸神少及，何以故，阎浮土地，悉蒙汝护，乃至草木沙石，稻麻竹苇，谷米宝贝，从地而有，皆因汝力，又常称扬地藏菩萨利益之事，汝之功德及以神通，百千倍于常分地神，若未来世中，有善男子、善女人，供养菩萨，及转读是经，但依地藏本愿经一事修行者，汝以本神力而拥护之，勿令一切灾害及不如意事，辄闻于耳，何况令受，非但汝独护是人故，亦有释梵眷属，诸天眷属，拥护是人，何故得如是圣贤拥护，皆由瞻礼地藏形像，及转读是本愿经故，自然毕竟出离苦海，证涅槃乐，以是之故，得大拥护。 见闻利益品第十二尔时，世尊从顶门上放百千万亿大毫相光，所谓白毫相光、大白毫相光、瑞毫相光、大瑞毫相光、玉毫相光、大玉毫相光、紫毫相光、大紫毫相光、青毫相光、大青毫相光、碧毫相光、大碧毫相光、红毫相光、大红毫相光、绿毫相光、大绿毫相光、金毫相光、大金毫相光、庆云毫相光、大庆云毫相光、千轮毫光、大千轮毫光、宝轮毫光、大宝轮毫光、日轮毫光、大日轮毫光、月轮毫光、大月轮毫光、宫殿毫光、大宫殿毫光、海云毫光、大海云毫光， 于顶门上放如是等毫相光已。出微妙音，告诸大众、天龙八部、人非人等：听吾今日于忉利天宫，称扬赞叹地藏菩萨于人天中，利益等事，不思议事，超圣因事，证十地事，毕竟不退阿耨多罗三藐三菩提事。 说是语时，会中有一菩萨摩诃萨，名观世音，从座而起，胡跪合掌白佛言：世尊！是地藏菩萨摩诃萨具大慈悲，怜愍罪苦众生，于千万亿世界，化千万亿身，所有功德及不思议威神之力，我闻世尊与十方无量诸佛，异口同音赞叹地藏菩萨云，正使过去现在未来诸佛说其功德，犹不能尽，向者又蒙世尊普告大众，欲称扬地藏利益等事，唯愿世尊为现在未来一切众生，称扬地藏不思议事，令天龙八部，瞻礼获福。 佛告观世音菩萨：汝于娑婆世界有大因缘，若天若龙，若男若女，若神若鬼，乃至六道罪苦众生，闻汝名者，见汝形者，恋慕汝者，赞叹汝者，是诸众生，于无上道，必不退转，常生人天，具受妙乐，因果将熟，遇佛受记，汝今具大慈悲，怜愍众生，及天龙八部，听吾宣说地藏菩萨不思议利益之事，汝当谛听，吾今说之。 观世音言：唯然世尊！愿乐欲闻。 佛告观世音菩萨：未来现在诸世界中，有天人受天福尽，有五衰相现，或有堕于恶道之者，如是天人，若男若女，当现相时，或见地藏菩萨形像，或闻地藏菩萨名，一瞻一礼，是诸天人，转增天福，受大快乐，永不堕三恶道报，何况见闻菩萨，以诸香华，衣服饮食，宝贝璎珞，布施供养，所获功德福利，无量无边。 复次观世音！若未来现在诸世界中，六道众生临命终时，得闻地藏菩萨名，一声历耳根者，是诸众生，永不历三恶道苦，何况临命终时，父母眷属，将是命终人舍宅财物，宝贝衣服，塑画地藏形像，或使病人未终之时，眼耳见闻，知道眷属将舍宅宝贝等，为其自身塑画地藏菩萨形像，是人若是业报，合受重病者，承斯功德，寻即除愈，寿命增益，是人若是业报命尽，应有一切罪障业障，合堕恶趣者承斯功德，命终之后，即生人天，受胜妙乐，一切罪障，悉皆消灭。 复次观世音菩萨！若未来世，有男子女人，或乳哺时，或三岁五岁十岁以下，亡失父母，乃及亡失兄弟姊妹，是人年既长大，思忆父母及诸眷属，不知落在何趣，生何世界，生何天中，是人若能塑画地藏菩萨形像，乃至闻名，一瞻一礼，一日至七日，莫退初心，闻名见形，瞻礼供养，是人眷属，假因业故，堕恶趣者，计当劫数，承斯男女，兄弟姊妹，塑画地藏形像，瞻礼功德，寻即解脱，生人天中，受胜妙乐，是人眷属，如有福力，已生人天，受胜妙乐者，即承斯功德，转增圣因，受无量乐，是人更能三七日中，一心瞻礼地藏形像，念其名字，满于万遍，当得菩萨现无边身，具告是人，眷属生界，或于梦中，菩萨现大神力，亲领是人，于诸世界，见诸眷属，更能每日念菩萨名千遍，至于千日，是人当得菩萨遣所在土地鬼神，终身卫护，现世衣食丰溢，无诸疾苦，乃至横事不入其门，何况及身，是人毕竟得菩萨摩顶授记。 复次观世音菩萨！若未来世，有善男子、善女人，欲发广大慈心，救度一切众生者，欲修无上菩提者，欲出离三界者，是诸人等，见地藏形像，及闻名者，至心归依，或以香华衣服，宝贝饮食，供养瞻礼，是善男女等，所愿速成，永无障碍。 复次观世音！若未来世，有善男子善女人，欲求现在未来百千万亿等愿，百千万亿等事，但当归依瞻礼，供养赞叹地藏菩萨形像，如是所愿所求，悉皆成就，复愿地藏菩萨具大慈悲，永拥护我，是人于睡梦中，即得菩萨摩顶授记。 复次观世音菩萨！若未来世，善男子、善女人，于大乘经典，深生珍重，发不思议心，欲读欲诵，纵遇明师教视令熟，旋得旋忘，动经年月，不能读诵，是善男子等，有宿业障，未得消除，故于大乘经典，无读诵性，如是之人，闻地藏菩萨名，见地藏菩萨像，具以本心恭敬陈白，更以香华，衣服饮食，一切玩具，供养菩萨，以净水一盏，经一日一夜，安菩萨前，然后合掌请服，回首向南，临入口时，至心郑重，服水既毕，慎五辛酒肉，邪淫妄语，及诸杀害，一七日或三七日，是善男子、善女人，于睡梦中，具见地藏菩萨现无边身，于是人处，授灌顶水，其人梦觉，即获聪明，应是经典，一历耳根，即当永记，更不忘失一句一偈。 复次观世音菩萨！若未来世有诸人等，衣食不足，求者乖愿，或多病疾，或多凶衰，家宅不安，眷属分散，或诸横事，多来忤身，睡梦之间，多有惊怖，如是人等，闻地藏名，见地藏形，至心恭敬，念满万遍，是诸不如意事，渐渐消灭，即得安乐，衣食丰溢，乃至于睡梦中，悉皆安乐。 复次观世音菩萨！若未来世有善男子、善女人，或因治生，或因公私，或因生死，或因急事，入山林中，过渡河海，乃及大水，或经险道，是人先当念地藏菩萨名万遍，所过土地，鬼神卫护，行住坐卧，永保安乐，乃至逢于虎狼师子，一切毒害，不能损之。 佛告观世音菩萨：是地藏菩萨，于阎浮提有大因缘，若说于诸众生见闻利益等事，百千劫中，说不能尽。是故观世音！汝以神力，流布是经，令娑婆世界众生，百千万劫永受安乐。尔时世尊，而说偈言： 吾观地藏威神力，恒河沙劫说难尽；见闻瞻礼一念间，利益人天无量事。若男若女若龙神，报尽应当堕恶道；至心归依大士身，寿命转增除罪障。少失父母恩爱者，未知魂神在何趣；兄弟姊妹及诸亲，生长以来皆不识。或塑或画大士身，悲恋瞻礼不暂舍；三七日中念其名，菩萨当现无边体。示其眷属所生界，纵堕恶趣寻出离；若能不退是初心，即获摩顶受圣记。欲修无上菩提者，乃至出离三界苦；是人既发大悲心，先当瞻礼大士像；一切诸愿速成就，永无业障能遮止。有人发心念经典，欲度群迷超彼岸，虽立是愿不思议，旋读旋忘多废失，斯人有业障惑故，于大乘经不能记，供养地藏以香华，衣服饮食诸玩具，以净水安大士前，一日一夜求服之，发殷重心慎五辛，酒肉邪淫及妄语，三七日内勿杀害，至心思念大士名，即于梦中见无边，觉来便得利根耳，应是经教历耳闻，千万生中永不忘，以是大士不思议，能使斯人获此慧。贫穷众生及疾病，家宅凶衰眷属离，睡梦之中悉不安，求者乖违无称遂，至心瞻礼地藏像，一切恶事皆消灭，至于梦中尽得安，衣食丰饶神鬼护。欲入山林及渡海，毒恶禽兽及恶人，恶神恶鬼并恶风，一切诸难诸苦恼，但当瞻礼及供养，地藏菩萨大士像，如是山林大海中，应是诸恶皆消灭。观音至心听吾说，地藏无尽不思议，百千万劫说不周，广宣大士如是力。地藏名字人若闻，乃至见像瞻礼者；香华衣服饮食奉，供养百千受妙乐。若能以此回法界，毕竟成佛超生死；是故观音汝当知，普告恒沙诸国土。 嘱累人天品第十三尔时，世尊举金色臂，又摩地藏菩萨摩诃萨顶，而作是言：地藏！地藏！汝之神力不可思议，汝之慈悲不可思议，汝之智慧不可思议，汝之辩才不可思议，正使十方诸佛赞叹宣说汝之不思议事，千万劫中不能得尽。 地藏！地藏！记吾今日在忉利天中，于百千万亿不可说不可说一切诸佛菩萨，天龙八部，大会之中，再以人天诸众生等，未出三界，在火宅中者，付嘱于汝，无令是诸众生，堕恶趣中，一日一夜。何况更落五无间及阿鼻地狱，动经千万亿劫，无有出期。 地藏！是南阎浮提众生，志性无定，习恶者多，纵发善心，须臾即退，若遇恶缘，念念增长，以是之故，吾分是形，百千亿化度，随其根性而度脱之。 地藏，吾今慇懃，以天人众，付嘱于汝，未来之世，若有天人，及善男子、善女人，于佛法中，种少善根，一毛一尘，一沙一渧，汝以道力，拥护是人，渐修无上，勿令退失。 复次地藏！未来世中，若天若人，随业报应，落在恶趣，临堕趣中，或至门首，是诸众生，若能念得一佛名，一菩萨名，一句一偈，大乘经典，是诸众生，汝以神力，方便救拔，于是人所，现无边身，为碎地狱，遣令生天，受妙胜乐。 尔时世尊而说偈言： 现在未来天人众，吾今慇懃付嘱汝；以大神通方便度，勿令堕在诸恶趣。 尔时，地藏菩萨摩诃萨胡跪合掌白佛言：世尊！唯愿世尊不以为虑，未来世中，若有善男子、善女人，于佛法中，一念恭敬，我亦百千方便，度脱是人，于生死中，速得解脱，何况闻诸善事，念念修行，自然于无上道永不退转。 说是语时，会中有一菩萨，名虚空藏，白佛言：世尊！我自至忉利，闻于如来赞叹地藏菩萨，威神势力，不可思议。未来世中，若有善男子、善女人，乃及一切天龙，闻此经典及地藏名字，或瞻礼形像，得几种福利，唯愿世尊，为未来现在一切众等，略而说之。 佛告虚空藏菩萨：谛听谛听！吾当为汝分别说之，若未来世，有善男子、善女人，见地藏形像，及闻此经，乃至读诵，香华饮食，衣服珍宝，布施供养，赞叹瞻礼，得二十八种利益： 一者，天龙护念；二者，善果日增；三者，集圣上因；四者，菩提不退；五者，衣食丰足；六者，疾疫不临；七者，离水火灾；八者，无盗贼厄；九者，人见钦敬；十者，神鬼助持；十一者，女转男身；十二者，为王臣女；十三者，端正相好；十四者，多生天上；十五者，或为帝王；十六者，宿智命通；十七者，有求皆从；十八者，眷属欢乐；十九者，诸横消灭；二十者，业道永除；二十一者，去处尽通；二十二者，夜梦安乐；二十三者，先亡离苦；二十四者，宿福受生；二十五者，诸圣赞叹；二十六者，聪明利根；二十七者，饶慈愍心；二十八者，毕竟成佛。 复次，虚空藏菩萨！若现在未来，天龙鬼神，闻地藏名，礼地藏形，或闻地藏本愿事行，赞叹瞻礼，得七种利益： 一者，速超圣地；二者，恶业消灭；三者，诸佛护临；四者，菩提不退；五者，增长本力；六者，宿命皆通；七者，毕竟成佛。 尔时，十方一切诸来，不可说、不可说诸佛如来，及大菩萨天龙八部，闻释迦牟尼佛，称扬赞叹地藏菩萨，大威神力，不可思议，叹未曾有。是时忉利天，雨无量香华，天衣珠璎，供养释迦牟尼佛，及地藏菩萨已，一切众会，俱复瞻礼，合掌而退。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>佛经</tag>
        <tag>文化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[You Are Not Late]]></title>
    <url>%2F2018%2F01%2F17%2Fyouarenotlate.html</url>
    <content type="text"><![CDATA[纽约时间比加州时间早三个小时，New York is 3 hours ahead of California,但加州时间并没有变慢。but it does not make California slow.有人22岁就毕业了，Someone graduated at the age of 22,但等了五年才找到稳定的工作！but waited 5 years before securing a good job!有人25岁就当上CEO，Someone became a CEO at 25,却在50岁去世。and died at 50.也有人迟到50岁才当上CEO，While another became a CEO at 50,然后活到90岁。and lived to 90 years.有人单身，Someone is still single,同时也有人已婚。while someone else got married.奥巴马55岁就退休，Obama retires at 55,川普70岁才开始当总统。but Trump starts at 70.世上每个人本来就有自己的发展时区。Absolutely everyone in this world works based on their Time Zone.身边有些人看似走在你前面，People around you might seem to go ahead of you,也有人看似走在你后面。some might seem to be behind you.但其实每个人在自己的时区有自己的步程。But everyone is running their own RACE, in their own TIME.不用嫉妒或嘲笑他们。Don’t envy them or mock them.他们都在自己的时区里，你也是！They are in their TIME ZONE, and you are in yours!生命就是等待正确的行动时机。Life is about waiting for the right moment to act.所以，放轻松。So, RELAX.你没有落后。You’re not LATE.你没有领先。You’re not EARLY.在命运为你安排的属于自己的时区里，一切都准时。You are very much ON TIME, and in your TIME ZONE Destiny set up for you. 大学室友在qq上发来的一段最近很火的诗。很喜欢，复制到这里，给自己加个油。]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我的2017年度总结]]></title>
    <url>%2F2018%2F01%2F01%2Fannual-review-2017.html</url>
    <content type="text"><![CDATA[请输入密码以访问这篇文章. 密码错啦! No content to display! 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]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阳仔带病打DOTA]]></title>
    <url>%2F2017%2F02%2F27%2Ftuoyouping.html</url>
    <content type="text"><![CDATA[阳仔拖油瓶记 广水阳仔，年方二八，丁酉年二月底患病，带病打dota。 然，战六局至午夜，连输五场。祸及队友。险跌分至一千内。 每思及此，阳仔不觉惭愧，而队友捶胸顿足，内心愤懑潸然泪下。 谨以此文，劝服阳仔，有病早治，无病早防。]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禹玮二愣子]]></title>
    <url>%2F2015%2F12%2F21%2Fyuwei2.html</url>
    <content type="text"><![CDATA[禹玮二愣子哈哈哈哈哈！]]></content>
  </entry>
  <entry>
    <title><![CDATA[WIN10快捷键]]></title>
    <url>%2F2015%2F08%2F11%2Fwin10-shortcut.html</url>
    <content type="text"><![CDATA[创建新的虚拟桌面：Win + Ctrl + D关闭当前虚拟桌面：Win + Ctrl + F4切换虚拟桌面： Win + Ctrl +左/右 切换窗口：Alt + Tab任务视图：Win + Tab Win键 桌面与开始菜单切换按键Win + R 打开运行对话框Win + A 操作中心Win + I Win10设置栏Ctrl+Alt+Del 任务管理器Alt+F4 关机快捷键 Win + 数字键：打开或切换位于任务栏指定位置的程序Win+D：显示桌面Win+ P：演示设置Win+L：锁住电脑或切换用户Win+PrtSc 截屏Win+ G 打开游戏录制Win+ALT+R屏幕录制]]></content>
      <tags>
        <tag>win10</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业事项记录]]></title>
    <url>%2F2015%2F04%2F17%2Fgraduation-note.html</url>
    <content type="text"><![CDATA[毕业论文及答辩 论文被抽查到盲审(50%概率)，送校外和校内各一位专家审查。审查结果分ABCD。A可直接参加校内答辩。 在学校内部hub系统上申请答辩。录入论文相关信息。 制作答辩PPT。 参加答辩。 填写档案袋以及(共6种资料)签字盖章。 根据答辩，重新修改完善论文，最终定稿。和档案袋一起上交。 在研究生院学位信息录入系统录入学位信息。 三方办理流程 找工作，与公司签两方工作意向协议。这个用于让自己放心。 拿到学校发的三方协议，自己签字，然后给公司盖章。 公司寄回三方协议，在学校就业网站填好毕业去向登记。三方找学院盖章。 将三方找学校就业办盖章。给一份就业办，给一份学院，自己留一份，给一份公司。 三方毁约流程因为和腾讯毁约。经历了三方毁约。发生在第一次给公司寄出三方之后。 找新单位开具工作接收函。 打电话找腾讯HR协商毁约，赔偿5K违约金，腾讯寄回三方和毁约声明。 拿三方、毁约声明、新单位接收函和个人毁约申请，去找学院盖章。 拿上述一堆材料，去研究生就业办，登记并领取新三方。 重新走正常三方办理流程。 户口、档案和派遣(待写) 带三方去和人才市场签订代理协议。 毕业了把档案和户口托管到人才市场。托管户口需要劳动合同和社保证明 党组织关系转移到公司。 其他事项 填写研究生就业推荐表 填写毕业研究生登记表]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux虚拟文件系统]]></title>
    <url>%2F2015%2F02%2F12%2Flinux-vfs.html</url>
    <content type="text"><![CDATA[本文Linux虚拟文件系统的几个重要对象。它们在Linux编程中比较重要。在进程编程等场景经常用到。 file对象file对象是在进程观点上，进程中打开的文件的表示。 dentry对象它表示一个实际的文件。不同进程打开同一个文件时，它们有不同的file对象，但是最终指向同一个dentry对象。 inode对象linux将文件与文件的属性分开表示。inode对象包含了一个文件相关的所有属性信息。比如文件大小，文件权限，操作方法集，对应的块设备，修改时间等。 super_block对象超级块对象。它包含磁盘上文件的一些元数据。是对文件系统具体的描述。 如下两张图，能够将这些对象的关系看得很清楚。 文件描述符从上图知道，在进程中打开的文件，对应的文件描述符，就是file_struct结构体中，file指针数组fd_array的下标。所以，进程打开文件时，分配的文件描述符按照从小到大的值依次分配。有了文件描述符，内核就能够去索引对应的file结构体，从fops去获得对文件的操作函数集，以便对文件进行各种操作。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>内核</tag>
        <tag>文件系统</tag>
        <tag>VFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分配malloc与sbrk]]></title>
    <url>%2F2015%2F02%2F12%2Fmalloc-sbrk.html</url>
    <content type="text"><![CDATA[malloc是C库函数。用于分配堆内存。是在运行时分配存储空间的函数。头文件: stdlib.h函数原型：void *malloc(unsigned int num_bytes); C库函数malloc1.组织结构空闲存储空间以空闲链表的方式组织，每个块包含一个长度，一个指向下一块的指针，以及一个指向自身存储空间的指针。按照存储地址升序组织。最后一块指向第一块。 2.分配过程有申请时，malloc顺序扫描空闲链表。直到找到一个足够大的块。算法为“首次适应”。寻找过程中，如果块大小等于需求大小，直接返回；如果块大小太大，分成两部分，一块为需求大小，将它返回(一般是块的后半部分)，另一块留在链表中；如果找不到足够大的块。调用sbrk向操作系统申请更大块加入空闲链表。 3.释放过程free首先搜索空闲块链表，找到相邻空闲块，则合并为一块。避免碎片。 Unix系统调用sbrk函数原型：char *sbrk(int incr); 它返回下一个内存空间。则sbrk(0)能得知堆的结束地址program break.sbrk是一个Linux的系统调用。它增加或者减少堆空间的长度。完成虚拟地址到物理地址的映射。在malloc申请空间不足时，malloc会调用sbrk来申请更多的内存加入到空闲块链表上。如下图，sbrk就是移动堆的program break的位置。 malloc/free与new/delete malloc是C标准库函数，new是C++的运算符。 对于用户自定义的对象而言，用malloc/free不能够执行构造函数和析构函数。因为malloc是库函数，不受编译器控制。 对于内置的数据对象，比如int char等，用new 和用malloc都可以。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存</tag>
        <tag>malloc</tag>
        <tag>sbrk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核定时器]]></title>
    <url>%2F2015%2F02%2F12%2Flinux-kernel-timer.html</url>
    <content type="text"><![CDATA[前提概念HZ：节拍率.linux一秒钟中断的次数，一般是100jiffies：系统从启动到当前的节拍数。如果系统启动n秒了，则 jiffies = n*HZ 头文件：linux/timer.h 12345678struct timer_list&#123; struct list_head entry; unsigned long expires; struct tvec_base *base; void (*function) (unsigned long); unsigned long data; .......&#125; 使用步骤 申请timer_list结构体 struct timer_list mytimer 初始化定时器init_timer(&amp;mytimer) 设置超时间隔，超时函数及其参数。 编写超时后处理函数 添加定时器add_timer(&amp;mytimer) 最终删除定时器del_timer_sync(&amp;mytimer)，该函数多处理器安全。 代码示例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/jiffies.h&gt;MODULE_LICENSE("Dual BSD/GPL");struct timer_list mytimer;int counter = 0;static void mytimer_handler(unsigned long data)&#123; printk("counter now:%d.\n",counter); counter ++; if (counter &gt;20) counter = 0; mod_timer(&amp;mytimer,jiffies + HZ);&#125;static int __init mytimer_init(void)&#123; printk("In function:%s\n",__func__); init_timer(&amp;mytimer); mytimer.expires = jiffies + HZ; mytimer.data = jiffies; mytimer.function = mytimer_handler; add_timer(&amp;mytimer); return 0;&#125;static void __exit mytimer_exit(void)&#123; printk("In function:%s\n",__func__); del_timer(&amp;mytimer);&#125;module_init(mytimer_init);module_exit(mytimer_exit); 程序中，每经过1秒定时器超时，count值加1并打印出来，然后mod_timer()修改定时器mytimer的expires值为再过1秒超时，再次激活定时器。 运行结果每隔一秒输出count值，count循环从0增加到20，直到手动卸载模块时，定时器被删除。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内核</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的多线程]]></title>
    <url>%2F2015%2F02%2F11%2Flinux-multi-thread.html</url>
    <content type="text"><![CDATA[一.Linux线程与进程的对比用户空间角度： 新进程创建时，申请独立的地址空间，包括堆、栈、代码段、数据段、BSS段等。并初始化为父进程的值。此后父子进程不能直接互相访问这些资源。 新线程创建时，只申请独立线程栈，与同进程的其它线程共享进程地址空间，包括的代码段、数据段、BSS段、堆、打开的库、mmap映射的文件、共享内存空间。 内核空间角度： Linux并不区分进程和线程。创建线程和进程时，都会创建新的PCB。 不同的是，新进程PCB的mm_struct会创建新地址空间；新线程PCB的mm_struct指向主进程的地址空间，与它共享。 总的说来进程是OS管理资源的基本单元；线程是Linux系统调度的基本单元。 二.线程基本操作头文件：pthread.h由于是POSIX线程库，gcc编译时要加上-pthread选项。 int pthread_create(p_tid,attr,func,arg);创建线程。新线程从func处开始执行，arg为传递给func的参数。 pthread_t pthead_self();获取线程自身tid。 pthread_exit(void *ptr);线程由自身退出，返回信息放在ptr里。 int pthread_join(tid, void **ptr);等待线程tid退出。ptr存放tid退出时返回信息。 int pthread_detach(tid);使线程tid进入分离状态。即线程自身独立出来。 int pthread_cancel(tid);取消同进程中的tid线程。它提出这个请求后立即返回。tid在可取消点的时候退出。 void pthread_cleanup_push(func,arg);void pthread_cleanup_pop(int execute);设置线程退出时需要调用的函数。 一个代码示例：123456789101112131415161718192021#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void *thread_func(void *arg)&#123; printf("msg from main:%s\n",(char *)arg); printf("thread id:%u\n",(unsigned)pthread_self()); pthread_exit("I am thread,exited");&#125;int main(int argc,char *argv[])&#123; pthread_t tid; void *thread_ret; pthread_create(&amp;tid,NULL,thread_func,"I am main"); pthread_join(tid,&amp;thread_ret); printf("msg from thread:%s\n",(char *)thread_ret); return 0;&#125; 运行结果：1234tao@taohi-xubuntu:~/linux_c$ ./pthread_exitmsg from main:I am mainthread id:3075636032msg from thread:I am thread,exited 三.线程私有数据一个全局变量，如果A线程修改了它，那么这个修改会在B线程可见。为了使得线程有私有全局变量，有如下接口：pthread_key_create(key,func);pthread_key_delete(key);pthread_setspecific(key,ptr);pthread_getspecific(key); 示例代码如下：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;pthread_key_t key;void *tid1_func(void *arg)&#123; int i=10; printf("set key:%d in tid1\n",i); pthread_setspecific(key,&amp;i); sleep(2); printf("in tid1,after tid2 ends,key:%d\n",*(int *)pthread_getspecific(key));&#125;void *tid2_func(void *arg)&#123; int j=20; printf("set key:%d in tid2\n",j); pthread_setspecific(key,&amp;j); printf("in tid2,key:%d\n",*(int *)pthread_getspecific(key));&#125;void destruct(void *t)&#123; printf("key addr:%p\n",t);&#125;int main(int argc,char *argv[])&#123; pthread_t tid1,tid2; pthread_key_create(&amp;key,destruct); pthread_create(&amp;tid1,NULL,tid1_func,NULL); pthread_create(&amp;tid2,NULL,tid2_func,NULL); pthread_join(tid1,NULL); pthread_join(tid2,NULL); pthread_key_delete(key); return 0;&#125; 运行结果：1234567tao@taohi-xubuntu:~/linux_c$ ./pthread_keyset key:10 in tid1set key:20 in tid2in tid2,key:20key addr:0xb6d8934cin tid1,after tid2 ends,key:10key addr:0xb758a34c 四.线程同步方法线程并发访问共享资源，带来不确定性。所以需要同步机制。 4.1互斥锁mutex互斥锁是二元变量。线程只有获得锁，才能操作临界资源。操作完释放锁。造成死锁原因： 线程对同一个互斥锁加锁两次； A拥有甲锁，等乙锁，同时B拥有乙锁，等甲锁。 使用接口：pthread_mutex my_mutex;pthread_mutex_init(&amp;my_mutex,NULL);pthread_mutex_lock(&amp;my_mutex); 试着加锁，锁不上就阻塞等待加锁。pthread_mutex_trylock(&amp;my_mutex); 试着加锁，锁不上就返回pthread_mutex_unlock(&amp;my_mutex);pthread_mutex_destroy(&amp;my_mutex); 4.2读写锁读写锁比互斥锁并发度更高:如果A线程获得写锁：其他线程不能获得任何锁；如果A线程获得读锁：其他线程可以获得读锁，不能获得写锁。 使用接口：pthread_rwlock_t rwlock;pthread_rwlock_init(&amp;rwlock,NULL);pthread_rwlock_destroy(&amp;rwlock);pthread_rwlock_rdlock(&amp;rwlock);pthread_rwlock_wrlock(&amp;rwlock);pthread_rwlock_unlock(&amp;rwlock); 4.3条件变量默默忽略 五.线程和信号 每个线程有单独的信号屏蔽集合。 对同一个信号，所有线程共享相同的信号处理程序。比如线程1注册了SIGUSR1的处理函数，那么线程2收到SIGUSR1也会去调用这个处理函数。 如果一个线程收到终止信号，其他所有线程都将终止。 线程操作接口：pthread_kill(tid,signo);向线程tid发送signo信号。 pthread_procmask(how,mask,oldmask);设置线程信号屏蔽集合。 sigwait()等待一个或者多个信号发生。 代码示例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void sig_handler(int signo)&#123; printf("tid=%u,sig=%d\n",(unsigned int)pthread_self(),signo);&#125;void *tid1_func(void *arg)&#123; int i; sigset_t set; signal(SIGUSR1,sig_handler); sigfillset(&amp;set); sigdelset(&amp;set,SIGUSR2); pthread_sigmask(SIG_SETMASK,&amp;set,NULL); for(i=0;i&lt;5;i++) &#123; printf("tid1=%u, set mask.\n",(unsigned int)pthread_self()); pause(); &#125;&#125;void *tid2_func(void *arg)&#123; int i; signal(SIGUSR2,sig_handler); for(i=0;i&lt;5;i++) &#123; printf("tid2=%u, not set mask.\n",(unsigned int)pthread_self()); pause(); &#125;&#125;int main(int argc ,char *argv[])&#123; pthread_t tid1,tid2; pthread_create(&amp;tid1,NULL,tid1_func,NULL); pthread_create(&amp;tid2,NULL,tid2_func,NULL); sleep(1); pthread_kill(tid1,SIGUSR1); sleep(1); pthread_kill(tid1,SIGUSR1); pthread_kill(tid1,SIGUSR2); pthread_kill(tid2,SIGUSR1); pthread_kill(tid2,SIGUSR2); sleep(1); pthread_kill(tid1,SIGKILL); pthread_join(tid1,NULL); pthread_join(tid2,NULL); return 0;&#125; 运行结果：123456789tao@taohi-xubuntu:~/linux_c$ ./pthread_signal tid1=3076352832, set mask. tid2=3067960128, not set mask. tid=3076352832,sig=12 tid=3067960128,sig=12 tid=3067960128,sig=10 tid2=3067960128, not set mask.tid1=3076352832, set mask.已杀死 六.线程属性控制int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);获取线程栈大小。通过stacksize指针返回。 int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);设置线程栈大小。 示例代码：123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;void *tid_func(void *arg)&#123; pthread_attr_t attr; size_t stack_size=0; pthread_attr_getstacksize(&amp;attr,&amp;stack_size); printf("default pthread stack size:%d KB\n",stack_size/1024); stack_size=4*1024*1024; pthread_attr_setstacksize(&amp;attr,stack_size); pthread_attr_getstacksize(&amp;attr,&amp;stack_size); printf("after modify,stack size:%d KB\n",stack_size/1024); pthread_exit(NULL);&#125;int main(int argc ,char *argv[])&#123; pthread_t tid; pthread_create(&amp;tid,NULL,tid_func,NULL); pthread_join(tid,NULL); return 0;&#125; 输出结果:123tao@taohi-xubuntu:~/linux_c$ ./pthread_stackdefault pthread stack size:8192 KBafter modify,stack size:4096 KB 可以看到linux下线程默认栈大小为8M]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>多线程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信之六：共享内存]]></title>
    <url>%2F2015%2F02%2F11%2Fipc-share-memory.html</url>
    <content type="text"><![CDATA[共享内存允许两个进程共享一个给定的存储区。所以数据不需要在两个进程间复制。这是最快的一种IPC。头文件:sys/shm.h 一.共享内存示意图↓ 二.地址映射示意图↓(APUE) 三.共享内存的数据结构shmid_ds1234567891011struct shmid_ds &#123;struct ipc_perm shm_perm; /* see Section 15.6.2 */size_t shm_segsz; /* size of segment in bytes */pid_t shm_lpid; /* pid of last shmop() */pid_t shm_cpid; /* pid of creator */shmatt_t shm_nattch; /* number of current attaches */time_t shm_atime; /* last-attach time */time_t shm_dtime; /* last-detach time */time_t shm_ctime; /* last-change time */.....&#125;; 四.共享内存操作接口 创建:shmget() 控制:shmctl() 挂载映射:shmat() 分离:shmdt() 删除:shmctl(shm_id,IPC_RMID,0) 五.注意事项 进程操作共享内存区，要注意同步问题，可用信号量来同步。 根据进程知识，fork一个子进程，它继承父进程挂载的共享内存。 如果用exec执行新程序，则挂载的共享内存将被卸载。 如果进程调用exit()，则挂载的共享内存与进程脱离关系。 六.示例代码利用信号量来给共享内存区同步。发送端：如果信号量为0，往共享区写数据，将信号量加1；接收端：如果信号量为1，读出共享区数据，将信号量减1。如果接收到“end”，则删除共享内存，信号量。通信结束。 发送端代码：(为了简洁没有做错误处理)123456789101112131415161718192021222324252627282930313233343536373839404142//shm_sem_sender.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;string.h&gt;int main(int argc,char *argv[])&#123; int running = 1; int shmid; int semid; int value; void *share_memp=NULL; struct sembuf sem; sem.sem_num=0; sem.sem_flg=SEM_UNDO; semid=semget((key_t)123456,1,0666|IPC_CREAT); //设置信号初始值为0 semctl(semid,0,SETVAL,0); shmid=shmget((key_t)654321,(size_t)2048,0600|IPC_CREAT); share_memp = shmat(shmid,NULL,0); while(running) &#123; value=semctl(semid,0,GETVAL); if(value==0) &#123; printf("write data operate\n"); printf("please input:"); scanf("%s",(char *)share_memp); sem.sem_op=1; semop(semid,&amp;sem,1); &#125; if(strcmp(share_memp,"end")==0) running--; &#125; shmdt(share_memp); return 0;&#125; 接收端代码：(为了简洁没有做错误处理)12345678910111213141516171819202122232425262728293031323334353637383940414243//shm_sem_recv.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;string.h&gt;int main(int argc,char *argv[])&#123; int running = 1; int shmid; int semid; int value; void *share_memp=NULL; struct sembuf sem; sem.sem_num=0; sem.sem_flg=SEM_UNDO; semid=semget((key_t)123456,1,0666|IPC_CREAT); //设置信号初始值为0 semctl(semid,0,SETVAL,0); shmid=shmget((key_t)654321,(size_t)2048,0600|IPC_CREAT); share_memp = shmat(shmid,NULL,0); while(running) &#123; value=semctl(semid,0,GETVAL); if(value==1) &#123; printf("read data operate\n"); sem.sem_op=-1; semop(semid,&amp;sem,1); printf("%s",(char *)share_memp); &#125; if(strcmp(share_memp,"end")==0) running--; &#125; shmdt(share_memp); shmctl(shmid,IPC_RMID,0); semctl(semid,IPC_RMID,0); return 0;&#125;]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信四、五：信号量和消息队列]]></title>
    <url>%2F2015%2F02%2F11%2Fipc-msg-semaphore.html</url>
    <content type="text"><![CDATA[System V提供的IPC机制有三种：信号量、消息队列、共享内存。本文介绍前两种。头文件:sys/msg.h 和 sys/ipc.h使用ipcs可以查看系统正使用的IPC工具： IPC的ID与key键每一个IPC都用唯一的ID来标识、使用。一般利用key键来获得一个IPC的ID。而key可以通过ftok()产生。key_t ftok(char *pathname,int id); IPC权限结构ipc_perm12345678struct ipc_perm&#123; uid_t uid; gid_t gid; uid_t cuid; gid_t cgid; mode_t mode; ......&#125;; 进程通信之五：消息队列通信12345678910111213struct msqid_ds &#123;struct ipc_perm msg_perm; msgqnum_t msg_qnum; /* # of messages on queue */msglen_t msg_qbytes; /* max # of bytes on queue */pid_t msg_lspid; /* pid of last msgsnd() */pid_t msg_lrpid; /* pid of last msgrcv() */time_t msg_stime; /* last-msgsnd() time */time_t msg_rtime; /* last-msgrcv() time */time_t msg_ctime; /* last-change time */...&#125;; 代码示例：发送端和接收端利用消息队列进行通信。通信示意图：发送端代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//msg_sender#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define KEY_PATH "/home/tao"struct msgbuf&#123; int type; char ptr[0];&#125;;int main(int argc,char *argv[])&#123; key_t key; key=ftok(KEY_PATH,100); int msgid; msgid=msgget(key,IPC_CREAT|0600); printf("msgid=%d\n",msgid); pid_t pid; pid=fork(); if(pid==0) &#123; while(1) &#123; printf("input msg to be sent:"); char buf[128]; fgets(buf,128,stdin); struct msgbuf *ptr = malloc(sizeof(struct msgbuf)+strlen(buf)+1); ptr-&gt;type=1;//发送消息类型为1的消息 memcpy(ptr-&gt;ptr,buf,strlen(buf)+1); msgsnd(msgid,ptr,strlen(buf)+1,0); free(ptr); &#125; &#125; else &#123; struct msgbuf&#123; int type; char ptr[1024]; &#125;; while(1) &#123; struct msgbuf mybuf; memset(&amp;mybuf,'\0',1024); msgrcv(msgid,&amp;mybuf,1024,2,0);//接受消息类型为2的消息 printf("receive msg:%s\n",mybuf.ptr); &#125; &#125;&#125; 接收端代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//msg_receiver#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define KEY_PATH "/home/tao"struct msgbuf&#123; int type; char ptr[0];&#125;;int main(int argc,char *argv[])&#123; key_t key; key=ftok(KEY_PATH,100); int msgid; msgid=msgget(key,IPC_CREAT|0600); printf("msgid=%d\n",msgid); pid_t pid; pid=fork(); if(pid==0)//子进程发送消息 &#123; while(1) &#123; printf("input msg to be sent:"); char buf[128]; fgets(buf,128,stdin); struct msgbuf *ptr = malloc(sizeof(struct msgbuf)+strlen(buf)+1); ptr-&gt;type=2; //发送消息类型为2的消息 memcpy(ptr-&gt;ptr,buf,strlen(buf)+1); msgsnd(msgid,ptr,strlen(buf)+1,0); free(ptr); &#125; &#125; else &#123; struct msgbuf&#123; int type; char ptr[1024]; &#125;; while(1) &#123; struct msgbuf mybuf; memset(&amp;mybuf,'\0',1024); int ret=msgrcv(msgid,&amp;mybuf,1024,1,0);//接受消息类型为1的消息 printf("receive msg:%s\n",mybuf.ptr); &#125; &#125; return 0;&#125; 进程通信之四：信号量通信一般用于避免并发访问共享资源。比如生产者消费者问题。用的比较少。没啥好说的。需要时补充。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
        <tag>消息队列</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信之三：信号]]></title>
    <url>%2F2015%2F02%2F03%2Fipc-signal.html</url>
    <content type="text"><![CDATA[信号是进程间唯一异步通信机制，是一种软中断。头文件：signal.hLinux一共定义了32个非实时信号。编号0-31。常见的如下：1234567891011121314151617181920212223#define SIGNAL 0#define SIGHUP 1#define SIGINT 2#define SIGQUIT 3#define SIGTRAP 5#define SIGABRT 6#define SIGBUS 7#define SIGFPE 8 //算术异常#define SIGKILL 9 //杀死信号，不能被屏蔽#define SIGUSR1 10 //用户信号1#define SIGSEGV 11 //段错误#define SIGUSR2 12 //用户信号2#define SIGPIPE 13 //写没有读进程的管道#define SIGALRM 14 //闹钟超时#define SIGTERM 15#define SIGCHLD 17 //子进程改变作业状态#define SIGCONT 18#define SIGSTOP 19 //停止作业。它不能被用户屏蔽#define SIGTSTP 20...... 信号0特别说明：“signal 0″ is kind of like a moral equivalent of “ping”.signal 0 is just used to check process is exists or not.Using “kill -0 NNN” in a shell script is a good way to tell if PID “NNN” is alive or not. 一、信号基本工作原理 task_struct含有与信号相关的signal_struct, sighand_struct, sigpending等关键结构体。 发送给进程的信号，如果是私有信号(只发给进程的信号)，则放到sigpending指向的链表； 发送给进程的信号，如果是共享信号 (进程的所有线程共享)，则放到signal指向的链表； 如果安装了信号(即注册了信号处理函数)，则信号处理函数放入相应的sighand指向的数组，数组有64项，下标对应的是信号编号。 当进程每次从内核态返回用户态，就会调用do_signal检查链表是否有信号要处理，如果有，则根据信号编号为下标，去sighand数组索引找到相应的信号处理函数，删除链表的该信号，并到用户空间执行该函数。否则执行默认处理。 二、信号集结构体sigset_t123typedef struct&#123; unsigned long sig[2];&#125;sigset_t; 所以sigset_t一共含有64bit。为Linux可声明的最大信号数。 其中，sig[0]的32bit从1-31bit就对应常用的编号为1-31的信号。0表示信号存在，1表示没有该信号。 不要直接操作这些bit位。定义变量sigset_t myset，有专用接口如下： sigemptyset(&amp;myset);清空myset，也就是使得数组元素的bit都为0； sigfillset(&amp;myset);填满信号集myset,也就是使数组元素bit都为1； sigaddset(&amp;myset,SIGUSR1)把myset数组里与信号SIGUSR1编号对应的bit位置为1，相当于添加了SIGUSR1到这个信号集。 sigdelset(&amp;myset,SIGUSR2)从信号集myset删除SIGUSR2信号。 sigismember(&amp;myset,signo) 返回1 表示signo在信号集，0表示不在. 三、发送信号int kill(pid_t pid, int signo);给指定进程发信号 raise(int signo);给进程自己发信号 unsigned int alarm(unsigned int seconds);发送定时信号。 四、安装信号用signal安装信号signal(signo,handler);表示对编号为signo的信号，处理函数为handler。例子：1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void sig_handler(int signo)&#123; printf(&quot;signo=%d\n&quot;,signo);&#125;int main()&#123; if(signal(SIGUSR1,sig_handler)==SIG_ERR) &#123; printf(&quot;can&apos;t catch SIGUSR1\n&quot;); &#125; pause(); return 0;&#125; 其中handler可以不自定义，取SIG_ERR、SIG_DFL(用默认处理方法) 、SIG_IGN(忽略该信号)。 用sigaction安装信号int sigaction(int signo,struct sigaction *act,struct sigaction *oldact);结构体sigaction包括信号处理函数，屏蔽信号集，信号标志等。如下：123456struct sigaction&#123; void *sa_sigaction(int,struct siginfo *,void *); sigset_t sa_mask; unsigned long sa_flags; ....&#125; signo表示要安装的信号，act表示即将安装使用的信号处理信息(处理函数等)，oldact存储之前安装的信号处理信息。示例代码：1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void sig_handler(int signo,siginfo_t *info,void *p)&#123; printf("signo=%d\n",signo); printf("siginfo-&gt;signo:%d\n",info-&gt;si_signo); printf("sender pid=%d\n",info-&gt;si_pid);&#125;int main()&#123; struct sigaction act,oldact; sigemptyset(&amp;act.sa_mask); act.sa_flags=SA_SIGINFO; act.sa_sigaction=sig_handler; sigaction(SIGUSR1,&amp;act,&amp;oldact); pause(); return 0;&#125; 运行结果(在另一个终端手动向该进程发送SIGUSR1信号)：1234tao@taohi-xubuntu:~/linux_c$ ./sigaction_sa_sigactionsigno=10siginfo-&gt;signo:10sender pid=15656 sig_handler第二个参数为siginfo_t *info。它用于返回一个结构体指针info给sig_handler，包含了许多与该信号产生原因相关的信息，供信号处理函数sig_handler使用。大致内容如下：1234567891011typedef struct siginfo&#123; int si_signo; //信号编号 int si_errno; //错误信息 int si_code; //信号产生原因代码 pid_t si_pid; //发送者的进程ID uid_t si_uid; //发送者实际用户ID void *si_addr; // int si_status; // long si_band; // ......&#125;siginfo_t; 五、信号的屏蔽信号屏蔽：如果某信号被屏蔽，即使信号传递到进程，进程并不响应处理，而是让它处于屏蔽状态。只有当解除屏蔽后，进程才捕获并响应该信号。SIGKILL和SIGSTOP信号不能被屏蔽。 信号忽略：进程捕获并处理该信号，但是处理方式就是直接忽略，什么也不做。int sigprogmask(int how,sigset_t *set,sigset_t *oldset);说明：set 和oldset都是信号集合。函数中how的取值： SIG_BLOCK：将set信号集，添加到当前进程屏蔽信号集； SIG_UNBLOCK:将set信号集合，从当前进程屏蔽信号集删除； SIG_SETMASK:设置set为当前进程屏蔽信号集。 示例代码：1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;void sighandler(int signo)&#123; printf("caught signo:%d\n",signo);&#125;int main()&#123; sigset_t newmask,oldmask,pendmask; //安装SIGUSR1的处理函数 signal(SIGUSR1,sighandler); sigemptyset(&amp;newmask); sigaddset(&amp;newmask,SIGUSR1); //屏蔽SIGUSR1 sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask); printf("SIGUSR1 blocked for 20s.\n"); sleep(20); //进程可以收到SIGUSR1，但是被屏蔽了，处于pending状态， //sigpending可以查看处于pending的所有信号。 sigpending(&amp;pendmask); if(sigismember(&amp;pendmask,SIGUSR1)) printf("SIGUSR1 is pending...\n"); //取消屏蔽SIGUSR1 printf("SIGUSR1 unblocked.\n"); sigprocmask(SIG_SETMASK,&amp;oldmask,NULL); return 0;&#125; 运行结果(在另一个终端不断发送SIGUSR1)：12345tao@taohi-xubuntu:~/linux_c$ ./sigprocmaskSIGUSR1 blocked for 20s.SIGUSR1 is pending...SIGUSR1 unblocked.caught signo:10 六、等待信号 pause()挂起当前进程，等待除了当前被屏蔽信号外的任意信号。此时才会唤醒进程。 int sigsuspend(sigset_t *set)将进程屏蔽信号集指定为set，等待除了set外的任意信号到达；到达后，处理到达的信号。然后sigsuspend返回，恢复之前的进程屏蔽信号集。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信之二：有名管道FIFO]]></title>
    <url>%2F2015%2F02%2F03%2Fipc-fifo.html</url>
    <content type="text"><![CDATA[有名管道FIFO是一个特殊文件。但并不是将信息真正存到磁盘，而是存到内存中。两个完全没有关联的进程，通过访问这个管道文件，实现进程间通信。 头文件#include &lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); 使用方式 创建一个FIFO文件：mkfifo(“/tmp/fifo”,0766)。 A进程以写方式打开FIFO文件：open(FIFO文件,O_WRONLY),调用write往里写数据。 B进程以读方式打开FIFO文件：open(FIFO文件,O_RDONLY),调用read读出数据。 阻塞现象 A进程以写(读)方式打开FIFO，将会阻塞在open()，直到B以读(写)方式打开FIFO。 默认方式下，若管道没有数据，读操作阻塞，直到有数据被写入。 默认方式下，若管道数据满了，写操作阻塞，直到有数据被读出。 实例代码程序fifo_write向管道写入数据1234567891011121314151617181920212223#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#define FIFO "/tmp/fifo"int main(int argc,char *argv[])&#123; int pipe_fd; int res; char buffer[]="helloworld!"; res=mkfifo(FIFO,0766); printf("PID %d opening FIFO O_WRONLY.\n",getpid()); pipe_fd=open(FIFO,O_WRONLY); printf("pipe_fd=%d.\n",pipe_fd); if(pipe_fd!=-1) res=write(pipe_fd,buffer,sizeof(buffer)); printf("PID %d finished.\n",getpid()); return 0;&#125; 程序fifo_read从管道读出数据：1234567891011121314151617181920212223242526#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#define FIFO "/tmp/fifo"int main(int argc,char *argv[])&#123; int pipe_fd; int bytes_read=0; char buffer[4096]; memset(buffer,'\0',4096); printf("PID %d opening FIFO O_WRONLY.\n",getpid()); pipe_fd=open(FIFO,O_RDONLY); printf("pipe_fd=%d.\n",pipe_fd); if(pipe_fd!=-1) &#123; bytes_read=read(pipe_fd,buffer,sizeof(buffer)); printf("read data:%s\n",buffer); &#125; printf("PID %d finished.\n",getpid()); return 0;&#125; 运行结果先在A窗口执行fifo_write，结果如下：12tao@taohi-xubuntu:~$ ./fifo_writePID 5163 opening FIFO O_WRONLY. 根据前面提到的阻塞现象，fifo_write阻塞在open()。 然后在B窗口执行fifo_read，结果如下：12345tao@taohi-xubuntu:~$ ./fifo_readPID 5165 opening FIFO O_WRONLY.pipe_fd=3.read data:helloworld!PID 5165 finished. 此时观察B窗口，不再被阻塞，结果如下：1234tao@taohi-xubuntu:~$ ./fifo_writePID 5163 opening FIFO O_WRONLY.pipe_fd=3.PID 5163 finished.]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
        <tag>FIFO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信之一：无名管道PIPE]]></title>
    <url>%2F2015%2F02%2F03%2Fipc-pipe.html</url>
    <content type="text"><![CDATA[基本概念无名管道是一种特殊类型文件。内核资源对应一段特殊内存。管道的数据流是单向的。 命令ulimit -p 查看管道最大值限制，默认为8*512Byte=4KB。由limit.h的宏PIPE_BUF定义。 头文件：#include &lt;unistd.h&gt; 原型：int pipe(int pipefd[2]); 若执行成功，pipefd内将存储两个文件描述符，指向管道的两端(pipefd[0]读,pipefd[1]写);若执行失败，返回值为-1。 读写管道用系统调用read和write，默认以阻塞方式读写。 工作原理 示例代码实现管道操作ls /home/tao|sort12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;int main(int argc,char *argv[])&#123; int fd[2]; if(pipe(fd)==-1) &#123; perror("pipe"); exit(-1); &#125; if(fork() == 0)//child process.用于sort &#123; dup2(fd[0],0); close(fd[1]); execlp("sort","sort",(char *)0); &#125; else &#123; if(fork()==0)//child process.用于ls &#123; dup2(fd[1],1); close(fd[0]); execlp("ls","ls","/home/tao",(char *)0); &#125; else &#123; close(fd[0]); close(fd[1]); wait(NULL); wait(NULL); &#125; &#125; return 0;&#125; 程序说明：主进程分别fork了两个子进程，主进程产生的管道由两个子进程共享使用(管道是文件，根据进程fork的原理，父子进程共享打开的管道文件)。一个子进程执行ls，用dup2将标准输出重定向到管道写端fd[1]，另一个子进程执行sort，dup2将标准输入重定向到fd[0],于是它从管道读端fd[0]获取需要sort的数据。这样就实现了主进程的两个子进程的通信。 执行结果：和执行 ls /home/tao|sort一模一样。 可以看出，为了共享同样的文件描述符，无名管道适合这种亲缘关系接近的子进程之间通信。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>pipe</tag>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程间通信总述]]></title>
    <url>%2F2015%2F02%2F03%2Flinux-ipc.html</url>
    <content type="text"><![CDATA[进程是独立的资源管理单元。不同进程之间需要交互信息，这就需要进程间通信。 Linux继承了Unix和System V的进程间通信方式。Linux支持的主要进程间通信机制如下图所示。这样看起来，有8种。后续按照编号逐一介绍。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>ipc</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的地址映射]]></title>
    <url>%2F2015%2F02%2F02%2Flinux-address-mapping.html</url>
    <content type="text"><![CDATA[地址类型80X86的体系结构，有如下三种地址： 逻辑地址是虚拟地址空间。就是每个进程使用的独立逻辑地址，通常为4GB。逻辑地址=段选择符(16bit) + 段内偏移(32bit)。常说的逻辑地址就是这32位段内偏移。 线性地址(虚拟地址)值从0x00000000到0xffffffff 物理地址就是物理地址。 映射过程当进程引用一个逻辑地址时，需完成逻辑地址到物理地址的转换：逻辑地址–(分段)–&gt;线性地址–(分页)–&gt;物理地址 逻辑地址-(分段)-&gt;线性地址 逻辑地址有两部分：段选择符(16bit)+offset(32bit) 段描述符：每个段由一个8字节的段描述符(Segment Descriptor)表示，存放着段首地址、段长度、特权级等信息。 GDT和LDT：全局描述符表GDT，局部描述符表LDT。存放段描述符。 gdtr和ldtr：寄存器。存放GDT和LDT在内存中的地址。 转换过程： 段选择符的TI字段，确定是选gdtr或者ldtr，这就确定了段描述符表的基地址; 段选择符的index字段，来计算段描述符的地址，即index字段的值乘以8，并将这个结果与GDTR或LDTR寄存器中的内容相加，得到了对应的段描述符表。 offset与段描述符表的Base值相加，得到线性地址。 对于Linux：它只有4个段，而且对应段描述符的Base值均为0.所以offset+base=offset.得出结论：Linux下，逻辑地址等于线性地址。 线性地址-(分页)-&gt;物理地址 32位线性地址=10(页目录)+10(页表)+12(页内偏移) cr3寄存器：存放正在使用的页目录物理地址。OS进程调度时，自动将当前进程页目录物理地址存入cr3寄存器。 页目录和页表都有1024项(2的10次方)。 缺页异常:如果页目录/页表里的preset标志为0，则将产生缺页异常。将从磁盘把相应页载入内存。 对于Linux：分页过程差不多，只不过Linux使用了多级页目录而已。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>地址映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内核container_of宏]]></title>
    <url>%2F2015%2F02%2F02%2Fkernel-container-of.html</url>
    <content type="text"><![CDATA[container_of 宏：123456struct demo_struct &#123; type1 member1; type2 member2; type3 member3; type4 member4; &#125;; 同时，在另一个地方，获得了变量demo中的某一个域成员变量的指针，比如：type3 *memp=xxx此时:struct demo_struct *demop = container_of(memp, struct demo_struct, member3); 说明:member3 是结构体demo_struct的一个成员名；memp是member3的指针。返回值是指向demo_struct结构的指针。 由此，container_of实现了：根据一个结构体变量中的一个域成员变量的指针，来获取指向整个结构体变量的指针。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核模块参数]]></title>
    <url>%2F2015%2F01%2F26%2Flinux-module-param.html</url>
    <content type="text"><![CDATA[在加载模块的时候，可以向模块传递参数值，供模块内部使用。 使用方法头文件:linux/moduleparam.h程序中:12int disk_size = 1024;module_param_named(size,disk_size,int,S_IRUGO); 加载模块时:#insmod param.ko size=2048此时，模块会用size的值2048，去替换模块内部disk_size的默认值1024。 代码实例123456789101112131415161718192021#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/moduleparam.h&gt; int disk_size=1024;module_param_named(size,disk_size,int,S_IRUGO); static int __init param_init(void)&#123; printk("module init:disk_size now:%d\n",disk_size); return 0;&#125; static void __exit param_exit(void)&#123; printk("exit module.\n");&#125; module_init(param_init);module_exit(param_exit);MODULE_LICENSE("GPL"); 运行结果[root@localhost param]# insmod param.ko size=2048[root@localhost param]# dmesg[158889.935447] module init:disk_size now:2048 想要简化，使得输入参数和代码内参数同名，则使用：module_param(disk_size,int,S_IRUGO);]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的常用命令]]></title>
    <url>%2F2015%2F01%2F24%2Flinux-commands.html</url>
    <content type="text"><![CDATA[压缩与打解包tar压缩、解压缩：bzip2、 gzip等打包、解包：tar *.gz gzip压缩的文件 *.bz2 bzip2 压缩的文件 *.tar tar程序打包的文件，未经过压缩 *.tar.gz tar程序打包的文件，经过gzip的压缩 *.tar.bz2 tar程序打包的文件，经过bzip2压缩 常用解包命令tar -zxvf filename.tar.gztar -jxvf filename.tar.bz2z：表示gzip压缩的文件j：表示bzip2压缩的文件x：表示这是解包操作；c表示是打包操作。v：显示操作的详细过程；f：指定后面的文件名字；如果要解压到指定目录：tar zxvf filename.tar.gz -C /dir 常用打包命令tar -zcvf bb.tar.gz aa.txt将aa.txt用gz压缩并打包为bb.tar.gz文件tar -jcvf bb.tar.bz2 aa.txt将aa.txt用gz压缩并打包为bb.tar.bz2文件 系统调用追踪stracestrace [cmd]查看cmd这个命令产生的系统调用。等号左边是系统调用和参数，右边是系统调用返回值。 strace -p [pid]查看进程pid的系统调用情况。常用于做debug分析。 strace –tt –cp [pid]常用作性能分析，统计进程产生的系统调用次数和耗时。 -o参数能够将结果输出到文件。 进程树查看pstree用于查看进程树状图，能直观看出进程之间的调用关系。 pstree [pid] -p]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>gdb</tag>
        <tag>tar</tag>
        <tag>strace</tag>
        <tag>pstree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的零长度数组]]></title>
    <url>%2F2015%2F01%2F23%2Fc-flexible-array.html</url>
    <content type="text"><![CDATA[零长度的数组一般见于结构体中。在Linux内核代码中比较常见。而直接声明零长度数组，例如char str[0];这是无法编译通过的。零长度的数组一般是放在结构体的最后一个成员的位置处，放在中间也是可以的。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct str1&#123; int len; int b; char s[0];&#125;; struct str2&#123; int len; char s[0]; int b;&#125;; int main()&#123; struct str1 *sp=NULL; struct str2 *sp2=NULL; printf("Before,sizeof str1:%d\n",sizeof(struct str1)); sp=(struct str1 *)malloc(sizeof(struct str1)+10); sp-&gt;len=100; sp-&gt;b=50; strcpy(&amp;sp-&gt;s[0],"abc"); puts(sp-&gt;s); printf("After,sizeof str1:%d\n",sizeof(struct str1)); printf("len:%d\t%p\n",sp-&gt;len,&amp;sp-&gt;len); printf("b:%d\t%p\n",sp-&gt;b,&amp;sp-&gt;b); printf("s:%s\t%p\n",sp-&gt;s,&amp;sp-&gt;s); printf("\nBefore,sizeof str2:%d\n",sizeof(struct str2)); sp2=(struct str2 *)malloc(sizeof(struct str2)+10); sp2-&gt;len=150; sp2-&gt;b=60; strcpy(&amp;sp2-&gt;s[0],"def"); puts(sp2-&gt;s); printf("After,sizeof str2:%d\n",sizeof(struct str2)); printf("len:%d\t\t%p\n",sp2-&gt;len,&amp;sp2-&gt;len); printf("b:%d\t%p\n",sp2-&gt;b,&amp;sp2-&gt;b); printf("s:%s\t\t%p\n",sp2-&gt;s,&amp;sp2-&gt;s); return 0;&#125; 这里的char s[0]指的是一个变长数组，有点类似指针，不过跟指针却有本质的区别： 该结构体分配内存空间时，在栈上一次性分配，是连续的。而且成员s不占结构体空间。 如果使用指针形式，改成char *ptr,则结构体分配时,ptr需要占结构体一个指针大小。结构体本身需要一次栈上分配，指针ptr所指内存需要一次堆内分配。需要2次。而且这样内存就不连续了。 结构体的大小，测试发现是8，即sizeof(int)+sizeof(int)，也就是说s指向的空间不属于结构体str,这块空间紧跟着结构体str1所代表的空间。因此对于一个struct str1 *型的指针变量申请内存有如下方法：sp=(struct str *)malloc(sizeof(struct str)+ 10);表示给s申请了10个字节的空间。 上面分析的是结构体str1，对于结构体str2，把s[0]放在了中间，因为它不占存储空间，则s和b的地址是一样的。所以对s 赋值，会将b的原值覆盖掉。 程序运行结果如下图：]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的typedef与define]]></title>
    <url>%2F2015%2F01%2F22%2Fc-typedef-define.html</url>
    <content type="text"><![CDATA[C语言的typedef是一个存储类声明说明符。是编译过程的一部分，但是并不分配存储空间。 typedef的作用定义一个标识符及关键字的别名。 typedef的用法 1.定义一般的别名例子一：typedef int * pint; 定义pint为int指针别名。则若定义:pint pa,pb; pa和pb都表示int型指针。例子二：typedef int A[10]; 定义A表示一个含10个整型的数组。则若定义 A number; number表示含10整型元素的数组，等同于int number[10]; 2.用于struct结构体别名1234typedef struct node&#123; int data; struct node *next;&#125;NODE; 则NODE node_a;等同于struct node node_a;显得方便。 3.typedef来定义与平台无关的类型假设要定义一个8字节的长整型LONGLONG：Linux下:typedef long long LONGLONG;Windows下:typedef uint_64 LONGLONG;这样不同的平台下，使用LONGLONG均没问题，修改typedef即可。 4.定义别名，简化复杂声明原声明:int *(*a[5])(int, char*);定义别名: typedef int *(*pfunc)(int,char *);之后，使用pfunc a[5]声明a即可。 typedef与define的区别typedef发生在编译中，是和int a=5这样类似的声明；define发生在预编译中，只是简单的字面上替换。举例说明：typedef int * pint; 声明pint为int *数据类型；#define pint2 int *; 简单将两者替换。pint a,b;则a和b都为整型指针,int *a和int *b；pint2 a,b;则会替换成 int *a,b;这样a是指针，b不是指针。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>typedef</tag>
        <tag>define</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的字节对齐]]></title>
    <url>%2F2015%2F01%2F21%2Fc-byte-align.html</url>
    <content type="text"><![CDATA[一、字节对齐的作用作用：便于cpu快速访问，同时合理的利用字节对齐可以有效地节省存储空间。 对于32位机来说，CPU一次能读取32位，则4字节对齐能够使cpu访问速度提高。 比如说一个long类型的变量，如果跨越了4字节边界存储，那么cpu要读取两次，这样效率就低了。但是在32位机中使用1字节或者2字节对齐，反而会使变量访问速度降低。 二、字节对齐的原则编译器结合当前的操作系统，确定字节对齐方式。所以和编译器、操作系统都有关。 目前对齐原则： X86_32位机：windows下：K字节大小的对象，起始地址要为K的整数倍。(用GCC和VC 6.0编译器测试)Linux下：除了2字节的类型按2的整数倍对齐，都默认4字节对齐。(GCC 编译器测试) X86_64 机器：Linux和windows：K字节大小的对象，起始地址要为K的整数倍。(查资料获得) 三、代码测试测试环境: x86 32位的Linux 和windows。编译器都使用GNU GCC.测试代码:1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;typedef struct&#123; int num1; int num2; double num3;&#125;A;typedef struct&#123; int num1; double num2; int num3;&#125;B;int main()&#123; printf("char:%d\n",sizeof(char)); printf("short:%d\n",sizeof(short)); printf("int:%d\n",sizeof(int)); printf("long:%d\n",sizeof(long)); printf("float:%d\n",sizeof(float)); printf("double:%d\n",sizeof(double)); printf("long long:%d\n",sizeof(long long)); printf("sizeof(A):%d\n",sizeof(A)); printf("sizeof(B):%d\n",sizeof(B)); return 0;&#125; 32位Linux下GCC的测试结果由于Linux下GCC默认4字节对齐，那么A、B结构体的存储方式分别如下图：程序的运行结果： 32位Windows 7 下GCC的测试结果：由于windows下的原则是：K字节的对象起始地址要是K的整数倍，那么:A结构体的存储方式如下图所示,占16字节： B结构体的存储方式如下图所示,占24字节。因为num1占了4字节，num3长度为8(K=8),那么它的起始地址要为8的倍数，为了满足这个条件，所以在num1后面要留出4字节的空白。最后在num2之后，也要留4字节空白，使得结构体为24字节。这样如果分配连续的该结构体对象，才能满足下一个结构体的起始地址为24的整数倍。程序运行结果:补充用windows VC6.0编译测试，发现sizeof(B)也为24.(VC倒是不认识long long类型) 四、修改字节对齐的方式使用伪指令#pragma pack (n)，C 编译器将按照n个字节对齐。使用伪指令#pragma pack ()，恢复默认对齐方式。12345678910111213#pragma pack(1)typedef struct&#123; char num1; int num2; char num3;&#125;C;#pragma pack()typedef struct&#123; char num1; int num2; char num3;&#125;D; C、D结构体内容相同，对齐方式不同：C按照1字节对齐，则sizeof(C)=6;D默认4字节对齐，则sizeof(D)=12.]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>linux</tag>
        <tag>字节对齐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组名与指针的区别]]></title>
    <url>%2F2015%2F01%2F20%2Farray-name-and-pointer.html</url>
    <content type="text"><![CDATA[指针指针是一种地址变量，而地址则是该变量的值。 指针是左值 。举例类比：int n=5; n是变量，5是值。指针类似于n, 地址类似于5. 数组名是一个地址值，一个符号地址常量。 数组名是右值 。用来存放数组的区域是一块在栈中静态分配的内存(非static情况)，而数组名是这块内存的代表，它被定义为这块内存的首地址。数组名是地址常量。 两个疑问1.作为形参的数组，不是会被转换为指针吗？2.如果形参是一个指针，数组名可以作为实参传递给那个指针，难道不是说明了数组名是一个指针吗？ 首先，C语言之所以把作为形参的数组看作指针，并非因为数组名可以转换为指针，而是因为当初ANSI委员会制定标准的时候，从C程序的执行效率出发，不主张参数传递时复制整个数组，而是传递数组的首地址，由被调函数根据这个首地址处理数组中的内容。那么谁能承担这种“转换”呢？这个主体必须具有地址数据类型，同时应该是一个变量，满足这两个条件的，非指针莫属了。要注意的是，这种“转换”只是一种逻辑看法上的转换，实际当中并没有发生这个过程，没有任何数组实体被转换为指针实体。 第二，函数参数传递的过程，本质上是一种赋值过程。C89对函数调用是这样规定的：函数调用由一个后缀表达式(称为函数标志符, function designator) 后跟由圆括号括起来的赋值表达式列表组成，在调用函数之前，函数的每个实际参数将被复制，所有的实际参数严格地按值传递。因此，形参实际上所期望得到的东西，并不是实参本身，而是实参的值或者实参所代表的值！举个例来说，对于一个函数声明：void fun(int i);我们可以用一个整数变量int n作实参来调用fun，就是fun(n)；当然，也正如大家所熟悉的那样，可以用一个整数常量例如10来做实参，就是fun(10) ,实际上，对于形参i来说，用来声明i的类型说明符int，所起的作用是用来说明需要传递给i一个整数，并非要求实参也是一个整数变量，i真正所期望的，只是一个整数，仅此而已，至于实参是什么，跟i没有任何关系，它才不管呢，只要能正确给i传递一个整数就OK了。当形参是指针的时候，所发生的事情跟这个是相同的。指针形参并没有要求实参也是一个指针，它需要的是一个地址，谁能给予它一个地址？显然指针、地址常量和符号地址常量都能满足这个要求，而数组名作为符号地址常量正是指针形参所需要的地址，这个过程就跟把一个整数赋值给一个整数变量一样简单！ PS:部分参考出处未知的网络文章，侵删。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C指针的复杂声明]]></title>
    <url>%2F2014%2F07%2F14%2Fc-pointer-complex-declaration.html</url>
    <content type="text"><![CDATA[C语言复杂声明解读顺序 和 () * char int 等 10个解读示例1.float (*p)[2]p是一个指针，指向含有2个float元素的数组。 2.char *p[5]p是一个数组，数组含有5个字符类型的指针。 3.char (*fp)(char *,int *)fp是一个函数指针，指向的函数形参为一个字符型指针和一个整形指针，函数返回值为字符型。 4.int *pf(float (*a)(int))pf是一个指针函数，它的参数又是一个函数指针，所指向的函数带一个int形参，返回值为float型。pf返回值为整形指针。 5.int (*pf(char *))[5]pf是一个指针函数，它的参数是一个字符指针，返回值为一个指针，指针指向含5个整形元素的数组。 6.char *(*p[2])(char *,char *)p是含2个元素的指针数组，元素类型是函数指针，所指向的函数形参为两个字符指针，返回值为字符指针。 7.int (*(*pf)(char *))[3]pf是函数指针，指向的函数带一个字符指针型的参数，返回值为指向长度为3的整形数组的指针。 8.char *(*a[2])(char(*)(int *),char*)a是有2个元素的函数指针数组，数组元素指向的函数有两个形参：第一个形参为函数指针，指向一个带整形指针形参，返回值为字符指针的函数，第二个参数为字符型指针。a的数组元素指向的函数返回值为字符型指针。 9.int (*(*pf[3])(char *))(char *)pf是有3个元素的函数指针数组，每个指针所指向的函数带char *类型的形参，返回值为一个函数指针，该指针所指向的函数带一个char *形参，返回值为int型。 10.char *(*(*(*f[2])(char *))[2])(char *,char *)f是长度为2的函数指针数组，数组元素指向的函数含有一个char *形参，返回值为指向含有2个函数指针元素的数组指针，这个数组里的函数指针指向的函数带2个char *型形参，返回值为char *类型。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的sizeof运算符]]></title>
    <url>%2F2014%2F07%2F13%2Fc-sizeof.html</url>
    <content type="text"><![CDATA[sizeof说明sizeof是一个编译时(compile-time)一元运算符。用于计算任意一对象的长度。由于是编译时计算出对象的大小，因此在预编译#if等语句中不能使用。用法：sizeof 对象 或者 sizeof(类型名)运算结果：等于指定对象或者类型占用的存储字节数。所得结果类型为size_t，无符号整型。 实例代码12345678910#include &lt;stdio.h&gt;void main()&#123; int a[10]; int *p=a; printf("数组a的长度:%d\n",sizeof a/sizeof a[0]); printf("size_t的大小:%d\n",sizeof(size_t)); printf("指针p的大小:%d\n",sizeof(p)); printf("hello字符串的大小(包含'\\0'):%d\n",sizeof("hello"));&#125; 运行结果]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sizeof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的const和static]]></title>
    <url>%2F2014%2F07%2F13%2Fc-const-static.html</url>
    <content type="text"><![CDATA[存储类声明符static: 局部static变量：作用域为局部函数内。函数被调用的过程中维持其值不变。已经初始化则存放在data段，未初始化则默认初始化为0，存放在bss段。 全局static变量：作用域为本文件内。已经初始化则存放在data段，未初始化则默认初始化为0，存放在bss段。 一个被声明为static的函数，只可被这一模块内的其它函数调用。其他模块文件不能访问它。 类型限定符const： 可以定义const常量。 const可以修饰函数的参数、返回值甚至函数的定义体。 被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。const int a;int const a;前两个都表示，a是一个常量整形数。const int *a;a是一个指向常整形数的指针（整形数是不可以修改的，但是指针可以）。int *const a;a是一个指向整形数据常指针（指针指向的整形数是可以修改的，但是指针是不可以修改的）int const *a const;a是一个指向常整形的常指针（指针指向的整数不可以修改，同时指针也不可以修改） C语言的const机制： 在最初的C标准中，并没有const，只是在有了C++后，才将const加入C的标准中。 在编译的过程中，编译器会检查代码中是否有对const变量进行修改的代码，如果有则向用户报错。编译过后，const变量就和普通变量相同了。而且，如果使用memset去修改const变量的内容，也完全没有问题，这就可以看出const修饰是属于编译层面的限制，一般不会涉及到运行层面。在C中，const是用于明确的标识出变量或者函数不能被修改，而且这种限制在编译层面进行约束。 对于局部const变量，存放在栈上，可以通过取地址操作，memset等进行修改； 对于全局const变量，存放在只读数据段rodata段，被操作系统保护，所以修改会引发段错误。 static和const代码：12345678910111213141516171819202122#include &lt;stdio.h&gt;static int a[3];const int b=2;void main()&#123; static int c; int i=0; while(i&lt;3) &#123; printf("global static a[%d]=%d\n",i,a[i]); i++; &#125; printf("local static c=%d\n",c); const int d=1; //局部const变量a分配在栈上，栈可以通过地址读写，所以 //可以通过地址修改a的值 int *pd= (int *)&amp;d; *pd=31; printf("local const d=%d\n",d); int *pb = (int *)&amp;b; *pb=20;//报段错误，因为全局const常量b分配在.rodata区，是只读的。&#125; 运行结果：]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>const</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言的输入输出]]></title>
    <url>%2F2014%2F07%2F12%2Fc-input-output.html</url>
    <content type="text"><![CDATA[这些输入输出函数接口，全都定义在stdio.h头文件中。下面是几个变量声明12345#define MAX 1024int n;char c;char *s;char str[512]; scanf()原型:int scanf(char *format,...)返回值：成功读取的变量数目，失败返回0从标准输入读入字符序列，按照format格式存入到其余参数中。scanf(&quot;%d&quot;,&amp;n);把输入当做一个数字存入n；scanf(&quot;%[^\n]&quot;,str);把字符串读入str，直到出现换行符’\n’,这样就可以用scanf读入带空格的字符串了。 fgetc()原型:int fgetc(FILE *stream)从流stream中读一个字符。可以将标准输入stdin作为它的实参，这时候从标准输入读取一个字符。 fputc()原型:int fputc(int character, FILE *stream); getchar()原型:int getchar(void)从标准输入一次读取一个字符并返回，遇到文件尾返回EOF。#define getchar(fgetc(stdin)) putchar()原型:int putchar (int character)#define putchar(c) fputc(c, stdout) gets()原型:char * gets (char *str);从标准输入stdin读取一个字符串，遇到换行或结束时候终止。它不检查数组str的大小，容易溢出，不要使用。 puts()原型:int puts (const char *str) fgets()原型:char * fgets (char *str, int num, FILE *stream);从流stream中读入最多num个字符到字符数组str中，当遇到换行符时、或读到num-1个字符时停止。自动加上’\0’空字符结尾。这个函数常用于输入带空格的字符串。 fputs()原型:int fputs (const char *str, FILE *stream)]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C程序的汇编级别运行过程]]></title>
    <url>%2F2014%2F07%2F12%2Fc-in-disassemble-level.html</url>
    <content type="text"><![CDATA[C语言程序的执行，函数调用过程，如果将代码从汇编级别来研究，看内存中的汇编程序怎么运行，将会对C程序的执行理解更加深入。 环境：Xubuntu GCC GDB C代码1234567891011int foo(int a,int b)&#123; int c=a+b; return c;&#125; int main(void)&#123; foo(2,3); return 0;&#125; 汇编代码 main函数c与汇编对照 foo函数C与汇编对照 汇编相关知识 eip寄存器：始终存放下一条要执行的指令地址； ebp寄存器：存放当前栈基址(栈底)； esp寄存器：存放当前栈顶地址； eax ebx ecx edx是一些普通寄存器，用于参数和返回类型等； mov A B ：相当于把A处的值存入B处； call xxx：相当于push eip 且 jmp xxx； leave：相当于mov ebp esp 且 pop ebp； ret：相当于pop eip；]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>汇编</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用笔记]]></title>
    <url>%2F2014%2F07%2F10%2Fgit-usage-notes.html</url>
    <content type="text"><![CDATA[git用来做代码版本管理非常合适和高效。 安装git在ubuntu下获得git非常容易：sudo apt-get install git git提交到远程池一次典型的过程，以在github建远程仓库为例，事先去github建立一个名字为test的repository之后：123456789git config --global user.name taohi //第一次使用git时设置git config --global user.email taohi@taohi.net //第一次时设置mkdir test &amp;&amp; cd test git init //本地仓库初始化vim hello.c git add hello.c //加入到staging areagit commit -m &quot;first file hello world&quot; //提交到本地repositorygit remote add origin git@github.com:taohi/test.git//设置origin别名git push -u origin master //提交到远程repository 当然，要事先在github上设置好本地电脑生成的ssh public key,允许本地电脑的权限。 git做一次merge管理git一般是一组人一起使用，在各自的本地repo与远程repo之间更新代码。在一定阶段后，比如说组内阶段1任务完成，此时需要将各自的分支下代码整合到master分支里。以我自己分支taohi为例，将其merge到远程master，过程如下：1234567891011git checkout master //进入本地master分支git merge taohi //把我的分支merge到master分支git checkout -t origin/xiaoming //取远程xiaoming的分支到我本地git pullgit checkout mastergit merge xiaoming //把小明的分支merge到master下 //如果还有其他人的分支，按上述方法都进行合并git push origin master //把本地最后合并好的master更新到远程池git tag topic1git push origin --tags结束。 git撤销一次merge合并我在master下手贱，merge了一个分支。马上想撤销这次merge。先git log 查看要撤销的这个merge操作的commit 编号，假设是fb10e4694ccc21321。执行：git reset --hard fb10e4694ccc21321。 git更换远程库地址比如之前用的github的库，地址为url-github现在用bitbucket的库，地址为url-bitbucket.123456git remote rm origingit remote add origin url-bitbucketgit push origin master``` ## git的其他常用命令 git ls-remote 查看远程所有的分支git remote -v 查看git远程详细地址git reset HEAD ^ 回滚到上一个提交点。注意上尖号git branch (branch_name) 查看(创建)分支git checkout branch_name 进入某分支`]]></content>
      <categories>
        <category>Linux使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下C程序的内存布局]]></title>
    <url>%2F2014%2F07%2F10%2Flinux-c-memory-layout.html</url>
    <content type="text"><![CDATA[C可执行程序的结构C程序语言在编译和连接后，生成可执行程序，作为文件存放在磁盘上它的结构如下: 1.代码段Text2.只读数据段RO Data3.读写数据段RW Data 其中RO Data和RW Data统称为初始化数据段initialized data。在可执行程序载入运行时，会产生地址映射，以上三部分会对应到程序的虚拟地址空间。除了以上三个区域外，还产生: 4.未初始化数据段BSS区域5.堆Heap区域6.栈Stack区域 各部分含义1.代码段(Code或Text)从0x08048000虚拟地址开始。代码段由程序中执行的机器代码组成。在C语言中，程序语句进行编译后，形成机器代码。在执行程序的过程中，CPU的程序计数器指向代码段的每一条机器代码，并由处理器依次运行。 2.只读数据段(RO data)存放const 常量，字符串常量等。使用这些数据的方式类似查表式操作，由于这些变量不需要更改，因此只需要放置在只读存储器中即可。 3.已初始化读写数据段(RW data)存放已初始化全局变量和static变量，这些变量需要占用存储空间，具有初值，供程序运行时读写。 4.未初始化数据段(BSS)存放未初始化全局变量和static变量。这些变量在程序运行之前，不占用存储空间。 5.堆(heap)堆内存只在程序运行时出现，一般由程序员分配和释放，比如malloc.在具有操作系统的情况下，如果程序没有释放，操作系统可能在程序(例如一个进程)结束后回收内存。 6.栈(stack)从0xC0000000开始往下低地址增长。栈内存只在程序运行时出现，在函数内部使用的变量、函数的参数以及返回值将使用栈空间，栈空间由编译器自动分配和释放。栈大小在linux下可以使用ulimit -s查看，linux默认8M。可以修改，比如：用ulimit -s 4096指定为4M。如果程序用栈太大就出现栈溢出，程序出现段错误并退出。比如无限递归。 示例代码分析12345678910111213141516171819const char ro[] = &#123;"this is read only data"&#125;; //只读数据区static char rw_1[] =&#123;"this is global read write data"&#125;; //已初始化读写数据段char BSS_1[ 100]; //未初始化数据段const char *ptrconst ="constant data"; //字符串放在只读取数据段int main()&#123; short b; //在栈上，占用2个字节 char a[100]; //在栈上开辟100个字节， 它的值是其首地址 char s[]="abcdefg"; //s在栈上，占用4个字节，"abcdefg"本身放置在只读数据区，占8个字节 char *p1; //p1在栈上，占用4个字节 char *p2="123456"; //p2 在栈上，p2指向的内容不能改，“123456”在只读数据区 static char rw_2[]=&#123;"local read write data"&#125;;//已初始化读写数据段 static char BSS_2[100]; //未初始化数据段 static int c = 0; //全局(静态)初始化区 p1=(char *)malloc(10 * sizeof(char)); //分配内存区域在堆区 strcpy(p1,"xxxx"); //“XXXX”放在只读数据区，占5个字节 free(p1); //使用free释放p1所指向的内存 return 0;&#125; 内存布局图]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>linux</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下gcc的编译流程]]></title>
    <url>%2F2014%2F07%2F08%2Fgcc-work-flow.html</url>
    <content type="text"><![CDATA[基本概念在linux系统上，从源文件到目标文件的转化是由编译器完成的。以hello.c程序的编译为例，如下:1tao@tao-R408P~$ gcc -o hello hello.c 在这里，gcc编译器读取源文件hello.c，并把它翻译成一个可执行文件 hello。这个翻译过程可分为四个阶段逐步完成 :预处理，编译，汇编，链接，如下图所示。 详细分析在未编译前，hello.c 的源代码如下：123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello, world\n&quot;); return 0;&#125; 第一步：预处理阶段执行命令: gcc -o hello.i -E hello.c或者执行： cpp -o hello.i hello.c (这里cpp不是值c plus plus,而是预处理器the C Preprocessor) 预处理器cpp根据以字符开头#开头的命令，修改原始C程序：比如hello.c中的第一行为 #include，预处理器便将stdio.h的内容直接插入到程序中。预处理之后得到文本文件hello.i，打开如下：1234567891011121314# 1 &quot;hello.c&quot;# 1 &quot;&quot;# 1 &quot;&lt;命令行&gt;&quot;# 1 &quot;hello.c&quot;# 1 &quot;/usr/include/stdio.h&quot; 1 3 4...extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));# 943 &quot;/usr/include/stdio.h&quot; 3 4# 2 &quot;hello.c&quot; 2int main()&#123; printf(&quot;hello, world\n&quot;); return 0;&#125; 在源代码的前面插入了stdio.h，整个hello.i 的行数由hello.c的6行变到了849行. 头文件搜索顺序gcc先找-I 参数设置的路径再找gcc的环境变量C_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJC_INCLUDE_PATH设置的路径最后再依次找系统目录/usr/include /usr/local/include 第二步：编译阶段执行命令: gcc -o hello.s -S hello.i或者执行：ccl -o hello.s hello.i编译器ccl 将文本文件hello.i 翻译为hello.s，这个文件里面包含一个汇编程序，如下：1234567891011121314151617181920212223242526272829.file &quot;hello.c&quot; .section .rodata.LC0: .string &quot;hello world&quot; .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushl %ebp .cfi_def_cfa_offset 8 .cfi_offset 5, -8 movl %esp, %ebp .cfi_def_cfa_register 5 andl $-16, %esp subl $16, %esp movl $.LC0, (%esp) call puts movl $0, %eax leave .cfi_restore 5 .cfi_def_cfa 4, 4 ret .cfi_endproc.LFE0: .size main, .-main .ident &quot;GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 汇编语言是非常有用的，因为它给不同高级语言的不同编译器提供了通用的输出语言。例如，C和Fortran 的在此步编译产生的输出文件都是一样的汇编语言。 第三步：汇编阶段执行命令: gcc -o hello.o -c hello.s或者执行： as -o hello.o hello.s汇编器as 将hello.s 翻译成机器语言保存在hello.o 中。这是个二进制文件 第四步：链接阶段执行命令: gcc -o hello hello.o或者执行： ld -o hello hello.o注意：hello程序调用了printf 函数，这个函数是标准C库中的一个函数，他保存在一个名为printf.o 的文件中，这个文件必须以某种方式合并到我们的hello.o的程序中。链接器ld 负责处理这种合并。结果得到hello 可执行文件，可以被加载到内存中由系统执行。 链接时库文件顺序gcc先找-L设置的路径再找环境变量LIBRATY_PATH设置的路径最后再依次找系统目录 /lib /usr/lib /usr/local/lib当有同名的静态库和动态库，动态库优先级更高。 第五步：执行程序如果程序链接了动态库，则运行时动态库的搜索顺序编译程序时直接指定动态库找环境变量LD_LIBRARY_PATH设置的路径找内定目录 /lib /usr/lib /usr/local/lib 最后总结编译器的编译过程:源文件–&gt;预处理–&gt;编译/优化–&gt;汇编–&gt;链接–&gt;可执行文件-&gt;加载执行。]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试器基本使用]]></title>
    <url>%2F2014%2F07%2F08%2Fgdb-debug-md.html</url>
    <content type="text"><![CDATA[常用命令 gcc -g a.c -o a.out，这样就可以调试a.out gdb a.out开始调试a.out focus 类似turbo C的界面，使得当前代码高亮实时显示。 list 15 从15行开始列出源码 b foo() 在foo()函数设置断点 b 20 在第20行设置断点 r 表示跑程序，run n 表示next，单步执行 display 变量一直显示某变量的值 p 变量 打印一次某变量的值 p *地址 打印内存某地址里的内容 info args 查看参数信息 汇编相关 layout asm 显示汇编代码 start 开始单步运行 disassemble 函数名 显示某函数的汇编代码 disassemble /m 显示当前函数汇编代码 si 表示step into，按汇编语句单步执行，深入被调函数 ni 表示step over，也是单步执行； info registers 查看所有寄存器的值 display $eax这样查看寄存器值 info frame 查看当前栈的概览信息 x/10x $sp按照16进制打印当前栈的前10个元素]]></content>
      <categories>
        <category>Linux编程</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>debug</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法C实现]]></title>
    <url>%2F2014%2F07%2F08%2Fsort-code-in-c.html</url>
    <content type="text"><![CDATA[排序的方法非常多，这篇博客进行总结。关键、常用的排序方法： 快速排序，提高效率的方法 堆排序 递归归并排序 非递归归并排序 下面是这些排序的代码,C语言实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a,int i,int j)&#123; int temp; temp=a[i]; a[i]=a[j]; a[j]=temp;&#125;//O(n**2) Stablevoid bubble_sort(int *a,int n)&#123; int i,j,temp; for (i=0;i&lt;n;i++) &#123; for(j=i+1;j&lt;n;j++) if(a[i]&gt;a[j]) swap(a,i,j); &#125;&#125;//O(n**2) Not Stable//和冒泡类似，只是减少了盲目交换的次数。void select_sort(int *a,int n)&#123; int i,j,k,temp; for(i=0;i&lt;n-1;i++) &#123; k=i; for(j=i+1;j&lt;n;j++) if(a[k]&gt;a[j]) k=j; if(i!=k) swap(a,i,k); &#125;&#125;//O(nlogn) Not stablevoid quick_sort(int *a,int left,int right)&#123; int last=left; int i; if(left&gt;=right) return ; swap(a,left,(left+right)/2); for(i=left+1;i&lt;=right;i++) if(a[i]&lt;a[left]) swap(a,++last,i); swap(a,left,last); quick_sort(a,left,last-1); quick_sort(a,last+1,right);&#125;//O(n**2) Stablevoid insertion_sort(int *a,int n)&#123; int i,j,temp; for(i=1;i&lt;n;i++) &#123; temp=a[i]; j=i-1; while(j&gt;=0 &amp;&amp; temp&lt;a[j]) &#123; a[j+1]=a[j]; j--; &#125; a[j+1] = temp; &#125;&#125;//O(nlogn) Not stablevoid shell_insert_sort(int *a,int n)&#123; int gap,i,j,temp; for(gap=n/2;gap&gt;0;gap/=2) for(i=gap;i&lt;n;i++) for(j=i-gap;j&gt;=0 &amp;&amp; a[j]&gt;a[j+gap];j-=gap) swap(a,j,j+gap);&#125;//O(nlogn) Not stable. O(1) spare space.void heap_adjust(int *a,int i,int n)&#123; int child,temp; for(temp=a[i];2*i+1 &lt; n;i=child) &#123; child = 2*i +1; if(child!=n-1 &amp;&amp; a[child+1]&gt;a[child]) ++child; if(temp &gt;= a[child]) break; a[i]=a[child]; &#125; a[i]=temp;&#125;void heap_sort(int *a,int n)&#123; int i; for(i=n/2 -1;i&gt;=0;i--) heap_adjust(a,i,n); for(i=n-1;i&gt;0;i--) &#123; swap(a,0,i); heap_adjust(a,0,i); &#125;&#125;void merge(int *array,int left,int m,int right)&#123; int i,j,k=0,l; //merged动态临时数组,将有序的array[left...m]和有序的array[m+1...right] //归并成新的有序数组存放到merged中 int *merged=(int *)malloc(sizeof(int)*(right-left+1)); // printf("merge--[%d %d] [%d %d]\n",left,m,m+1,right); for(i=left,j=m+1;i&lt;=m &amp;&amp; j&lt;=right;k++) &#123; if(array[i]&lt;=array[j]) merged[k]=array[i++]; else merged[k]=array[j++]; &#125; //如果比较完后，前半部分还有剩的，直接接到merged后面 if(i&lt;=m) &#123; for(;i&lt;=m;k++) merged[k]=array[i++]; &#125; //如果比较完后，后半部分还有剩的，直接接到merged后面 if(j&lt;=right) &#123; for(;j&lt;=right;k++) merged[k]=array[j++]; &#125; //将有序的merged拷贝到原始array[left...right] for(l=left,k=0;l&lt;=right;l++) array[l]=merged[k++]; free(merged);&#125;//归并排序，递归版本//O(nlogn) Stable. spare space O(n+logn)void merge_sort_rec(int *a,int left,int right)&#123; int i=0; if(left&lt;right) &#123; i=(left + right)/2; merge_sort_rec(a,left,i); merge_sort_rec(a,i+1,right); merge(a,left,i,right); &#125;&#125;//归并排序，非递归版(推荐)void merge_sort(int *a,int left,int right)&#123; int i=0,k=2; //数组的长度=right+1 //k是归并时增长的步长 while(k&lt;=right+1) &#123; i=0; //内while循环归并后的序列长度为k while(i+k&lt;=right+1) &#123; //printf("merge(%d,%d,%d)\n",i,i+k/2-1,i+k-1); merge(a,i,i+k/2-1,i+k-1); i+=k; &#125; //如果剩下两个子序列,他们肯定不够while里的归并长度，在这里把他们归并 //如果不剩(i==right)或者只剩一个子序列(i+k/2-1==right)，什么也不用做 if(i+k/2-1&lt;right) &#123; merge(a,i,i+k/2-1,right); //printf("merge(%d,%d,%d)\n",i,i+k/2-1,right); &#125; k*=2; &#125; //最后一次归并 //printf("last merge(%d,%d,%d)\n",left,k/2-1,right); merge(a,left,k/2-1,right);&#125;void print(int *a,int n)&#123; int i; for(i=0;i&lt;n;i++) printf("%5d",a[i]); printf("\n");&#125;void main()&#123; int a1[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a2[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a3[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a4[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a5[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a6[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a7[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; int a8[]=&#123;13,0,5,8,1,7,21,50,9,2&#125;; bubble_sort(a1,10); print(a1,10); select_sort(a2,10); print(a2,10); quick_sort(a3,0,9); print(a3,10); insertion_sort(a4,10); print(a4,10); shell_insert_sort(a5,10);print(a5,10); heap_sort(a6,10); print(a6,10); merge_sort_rec(a7,0,9); print(a7,10); merge_sort(a8,0,9); print(a8,10); //如果排序前要手动获得数组长度，用sizeof： //printf("Array a1 length =%d\n",sizeof(a1)/sizeof(a1[0]));&#125;]]></content>
      <categories>
        <category>数据结构算法</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试笔试题目]]></title>
    <url>%2F2014%2F07%2F08%2Finterview-questions.html</url>
    <content type="text"><![CDATA[百度实习1面 堆和栈的区别 malloc的底层机制？ 进程和线程的区别 进程之间有哪些通信方式 如何创建共享内存？通过malloc吗？ 知道哪些排序算法？它们的稳定性和复杂度怎样？为什么快排的平均时间复杂度是O(nlgn)？ 算法题：两个字符串s1和s2，判断s2是否是s1的旋转字符串。 问我有什么问题要问他的？ 百度实习2面 2014年5月5日 typedef定义一个含有10个整型数的数据类型；typedef int x[10]; 怎么根据数组名字求数组长度；sizeof(a)/sizeofsizeof(a[0]); 写代码。查看某个值在不在给定二叉树中；递归函数实现; 写代码，按顺序输出二叉排序树的各个节点值；递归函数实现； 海量日志，含有关键字，几亿条，关键字有重复，内存放不下，输出重复率最高的前100个关键字（hash切割小文件+hash_map统计频率+堆排序输出）; SSD的分类，优缺点，损耗均衡的实现；为啥要自己实现驱动，不是用linux提供的？（MLC 和SLC ，MLC寿命短，密度高，SLC寿命长，密度低。）; 对面向对象的理解，（不会c++，举例linux内核关于文件系统的实现inode，dentry等，C语言实现面向对象的思想）; static关键字的各种用法以及区别. 百度广告优化部面试 2014年5月27日下午 人生规划，未来2年规划，方向。谈N久，扯。 百度搜索风云榜刚过去的一天，query热点统计，时间滑动窗口； 设计一个类，含有push pop 和min求最小值功能，使得这几个操作时间复杂度为O(1)。 他讲他们的日常工作。 单链表打印倒数第K个节点值。 网易游戏研发一面 2014年6月11日下午 SSD项目各种，会不会C++； 内存地址映射。虚拟地址–&gt;逻辑地址–&gt;物理地址映射的详细实现过程； static关键字的作用，声明的变量与普通变量的区别，如何在工程里若干个文件里共享全局变量，工程生成可执行目标的过程； 递归要注意的事项，递归如果无限下去会怎么办，递归的栈没了会怎么样，等等； 函数调用过程中，汇编级别是如何完成的，函数如何被调用，入栈，指令计数器怎么工作； 单项链表反转，完全写代码说出来；电话面试写代码讲述很烦。 判断两个单项链表是否有公共节点。要求：只遍历一次，不用额外空间，考虑环。 如何判断链表是否存在环； 时间不够了，结束。 网易游戏研发二面 时间：2014年6月18日下午 项目，SSD的垃圾回收，如何判断是不是垃圾。会不会c++； 生成exe过程，C代码变成汇编代码的详细过程，编译原理你学过吗？ 进程里的多线程的栈是共享的吗？堆是共享的吗？ 进程如果malloc很大一个内存块，会发生什么？ 递归栈溢出你怎么办？ 如何把递归转换成非递归呢？ C++ STL库你知道吗？ 可执行文件在内存中的布局； 重点问题：2D平面，怪物很多，静止不动。一架飞机，在飞，一边丢炸弹，炸怪物。知道炸弹的坐标，爆炸半径，知道所有怪物的坐标（存放在数组中），那么如何判断这个炸弹能炸死哪些怪物？（分区间排序。他说四叉树？？） 告诉我游戏开发，引擎用C++，逻辑用python和Lua等； 问我实习时间。有没有其他offer。]]></content>
      <categories>
        <category>面试笔试</category>
      </categories>
      <tags>
        <tag>面试笔试</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[什么也没有…]]></content>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[所有标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
